

# 前端三件套

## 0.Typora使用教程

| 常用编辑 | 快捷键 | 激活代码                                                |
| -------- | ------ | ------------------------------------------------------- |
| n级标题  | ctrl+n | n个#号加空格                                            |
| 字体加粗 | ctrl+b | ** （内容）  **                                         |
| 序号     |        | 1. 加空格                                               |
| 圆圈列表 |        | +加空格 （退出列表，输入enter键两次，前提是下行无下文） |
| 代码块   |        | ```加空格输入想输入的语言名称                           |
| 斜体     | ctrl+l | * （内容）   *  （ 加粗且斜体就三个*）                  |
| 下划线   | ctrl+u | <u> (内容）    </U>                                     |

无序列表的嵌套：+ 空格然后enter然后删除然后再+ 空格

- 一级无序列表
  - 二级无序列表
    - 三级无序列表

## Document

当浏览器载入 HTML 文档, 它就会成为 **Document 对象**。

Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。

### Document 对象属性和方法

属性：

document.activeElement：获取当前焦点元素

document.body：返回文档的body元素

| 属性                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [document.activeElement](https://www.runoob.com/jsref/prop-document-activeelement.html) | 返回当前获取焦点元素                                         |
| [document.anchors](https://www.runoob.com/jsref/coll-doc-anchors.html) | 返回对文档中所有 Anchor 对象的引用。                         |
| document.applets                                             | 返回对文档中所有 Applet 对象的引用。**注意:** HTML5 已不支持 <applet> 元素。 |
| [document.baseURI](https://www.runoob.com/jsref/prop-doc-baseuri.html) | 返回文档的绝对基础 URI                                       |
| [document.body](https://www.runoob.com/jsref/prop-doc-body.html) | 返回文档的body元素                                           |
| [document.cookie](https://www.runoob.com/jsref/prop-doc-cookie.html) | 设置或返回与当前文档有关的所有 cookie。                      |
| [document.doctype](https://www.runoob.com/jsref/prop-document-doctype.html) | 返回与文档相关的文档类型声明 (DTD)。                         |
| [document.documentElement](https://www.runoob.com/jsref/prop-document-documentelement.html) | 返回文档的根节点                                             |
| [document.documentMode](https://www.runoob.com/jsref/prop-doc-documentmode.html) | 返回用于通过浏览器渲染文档的模式                             |
| [document.documentURI](https://www.runoob.com/jsref/prop-document-documenturi.html) | 设置或返回文档的位置                                         |
| [document.domain](https://www.runoob.com/jsref/prop-doc-domain.html) | 返回当前文档的域名。                                         |
| document.domConfig                                           | **已废弃**。返回 normalizeDocument() 被调用时所使用的配置。  |
| [document.embeds](https://www.runoob.com/jsref/coll-doc-embeds.html) | 返回文档中所有嵌入的内容（embed）集合                        |
| [document.forms](https://www.runoob.com/jsref/coll-doc-forms.html) | 返回对文档中所有 Form 对象引用。                             |
| [document.images](https://www.runoob.com/jsref/coll-doc-images.html) | 返回对文档中所有 Image 对象引用。                            |
| [document.implementation](https://www.runoob.com/jsref/prop-document-implementation.html) | 返回处理该文档的 DOMImplementation 对象。                    |
| [document.inputEncoding](https://www.runoob.com/jsref/prop-document-inputencoding.html) | 返回用于文档的编码方式（在解析时）。                         |
| [document.lastModified](https://www.runoob.com/jsref/prop-doc-lastmodified.html) | 返回文档被最后修改的日期和时间。                             |
| [document.links](https://www.runoob.com/jsref/coll-doc-links.html) | 返回对文档中所有 Area 和 Link 对象引用。                     |
| [document.readyState](https://www.runoob.com/jsref/prop-doc-readystate.html) | 返回文档状态 (载入中……)                                      |
| [document.referrer](https://www.runoob.com/jsref/prop-doc-referrer.html) | 返回载入当前文档的文档的 URL。                               |
| [document.scripts](https://www.runoob.com/jsref/coll-doc-scripts.html) | 返回页面中所有脚本的集合。                                   |
| [document.strictErrorChecking](https://www.runoob.com/jsref/prop-document-stricterrorchecking.html) | 设置或返回是否强制进行错误检查。                             |
| [document.title](https://www.runoob.com/jsref/prop-doc-title.html) | 返回当前文档的标题。                                         |
| [document.URL](https://www.runoob.com/jsref/prop-doc-url.html) | 返回文档完整的URL                                            |

方法：

document.addEventListener()：向文档添加事件句柄

| 方法                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [document.addEventListener()](https://www.runoob.com/jsref/met-document-addeventlistener.html) | 向文档添加句柄                                               |
| [document.adoptNode(node)](https://www.runoob.com/jsref/met-document-adoptnode.html) | 从另外一个文档返回 adapded 节点到当前文档。                  |
| [document.close()](https://www.runoob.com/jsref/met-doc-close.html) | 关闭用 document.open() 方法打开的输出流，并显示选定的数据。  |
| [document.createAttribute()](https://www.runoob.com/jsref/met-document-createattribute.html) | 创建一个属性节点                                             |
| [document.createComment()](https://www.runoob.com/jsref/met-document-createcomment.html) | createComment() 方法可创建注释节点。                         |
| [document.createDocumentFragment()](https://www.runoob.com/jsref/met-document-createdocumentfragment.html) | 创建空的 DocumentFragment 对象，并返回此对象。               |
| [document.createElement()](https://www.runoob.com/jsref/met-document-createelement.html) | 创建元素节点。                                               |
| [document.createTextNode()](https://www.runoob.com/jsref/met-document-createtextnode.html) | 创建文本节点。                                               |
| [document.getElementsByClassName()](https://www.runoob.com/jsref/met-document-getelementsbyclassname.html) | 返回文档中所有指定类名的元素集合，作为 NodeList 对象。       |
| [document.getElementById()](https://www.runoob.com/jsref/met-document-getelementbyid.html) | 返回对拥有指定 id 的第一个对象的引用。                       |
| [document.getElementsByName()](https://www.runoob.com/jsref/met-doc-getelementsbyname.html) | 返回带有指定名称的对象集合。                                 |
| [document.getElementsByTagName()](https://www.runoob.com/jsref/met-document-getelementsbytagname.html) | 返回带有指定标签名的对象集合。                               |
| [document.importNode()](https://www.runoob.com/jsref/met-document-importnode.html) | 把一个节点从另一个文档复制到该文档以便应用。                 |
| [document.normalize()](https://www.runoob.com/jsref/met-document-normalize.html) | 删除空文本节点，并连接相邻节点                               |
| [document.normalizeDocument()](https://www.runoob.com/jsref/met-document-normalizedocument.html) | 删除空文本节点，并连接相邻节点的                             |
| [document.open()](https://www.runoob.com/jsref/met-doc-open.html) | 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 |
| [document.querySelector()](https://www.runoob.com/jsref/met-document-queryselector.html) | 返回文档中匹配指定的CSS选择器的第一元素                      |
| [document.querySelectorAll()](https://www.runoob.com/jsref/met-document-queryselectorall.html) | document.querySelectorAll() 是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 |
| [document.removeEventListener()](https://www.runoob.com/jsref/met-document-removeeventlistener.html) | 移除文档中的事件句柄(由 addEventListener() 方法添加)         |
| [document.renameNode()](https://www.runoob.com/jsref/met-document-renamenode.html) | 重命名元素或者属性节点。                                     |
| [document.strictErrorChecking](https://www.runoob.com/jsref/prop-document-stricterrorchecking.html) | 设置或返回是否强制进行错误检查。                             |
| [document.write()](https://www.runoob.com/jsref/met-doc-write.html) | 向文档写 HTML 表达式 或 JavaScript 代码。                    |
| [document.writeln()](https://www.runoob.com/jsref/met-doc-writeln.html) | 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。  |

## 一.HTML

### 1.1 HTML的入门

#### **1.11 附录：web标准的理解：**

1. 结构:HTML

   注释：<!--  内容-->

2. 表现:CSS

   /* 内容 */

3. 行为:交互，DOM，JavaScript

   //单行

   /* */多行

**HTML概念:** 

Hyper Text Markup Language 超文本标记语言，通过一组标签来对内容进行描述，设计的网页的基础：HTML5。

#### 1.12 HTML基本框架：

```html
<!DOCTYPE html> 文档声明
通过标签来对内容进行描述,标签通常由开始标签和结束标签组成，不区分大小写, 官方建议使用小写
<html>  根标签:包括两部分：头标签和体标签
   <head> 头部分：放置页面的一些信息，例如字体、页面名称、页面图标等
		<meta charset="UTF-8"> 定义其他HTML元素无法描述的元数据，即语言使用
		<title></title> 标题标签：显示在浏览区的标题栏，只解析文本，不会解析标签
	</head>
    <body> 体部分：唯一、放置HTML页面内容
    </body>
</html>
```

#### 1.13 HTML常用简单标签：

```html
常在头部分使用的：
<style></style> 设置CSS样式
<link></link> 链接CSS文件到该文档
  1，使用 <!--在网页标题左侧和收藏夹导入图标
			rel="icon/shortcut icon"
			type="image/x-icon"
			图标的后缀必须是.ico
		-->
		<link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />

<script></script> 内联脚本或外接脚本
<template></template> 实例化容器

在体部分使用的：
<p></p>  段落标签，自动换行
<h1></h1> 标题标签：最多1~6，依次减小字体大小，若超过则直接变成文本字体大小
<section></section> 定义章节
<ol></ol> 有序列表
<ul></ul> 无序列表
<li></li>列表项
<hr /> 水平线分隔符
<br> 换行
<em></em> 斜体，有语义
<i></i> 斜体，无语义
<strong></strong> 加粗，有语义
<b></b> 加粗，无语义
<!-- 注释：快捷键ctrl+/
-->
<u></u>下划线

快速使用emment插件创建标签：
> 嵌套(后代) 
+并列(兄弟) 
*重复 
^上级(父级) 
^^上上级 
.[类名]生成类 
#[id名]生成ID 
()包裹
$编号  例如：li.item$*5 生成五个li标签，类名分别是：item1~5
1.生成多位数的编号：三位数：$$$
2.倒序：$@-*5  生成五个li标签，类名分别是：item5~1
3.自定义初始下标：$@3*5：从3开始，类名分别是：item3~8
[]自定义属性： 例如：input[type='password' id='password']*5
{}生成文本
```

#### 1.14 HTML常用进阶标签(与CSS关联)

- img 标签中的路径问题

绝对路径：文件在磁盘的路径

相对路径：相对于当前HTML文件的路径

./代表的是当前路径
../ 代表的上一级路径
../../	上上一级路径

- table标签的应用

1，嵌套和合并，在td中可以嵌套一个表格，跨行或者跨列操作之后，被占掉的格子需要删除掉

2，以表格嵌套合并为基础设计网页框架

**实战项目--商城首页--需求分析**：

```html
<font></font> 
字体标签：
标签常用属性
color: 颜色
size : 改变字体大小  范围:1~7
face : 字体

<img/>
图片标签：
src : 指定图片路径
width : 指定图片宽度
height : 图片高度
alt : 文件加载失败时的提示信息

<ul>
    <li></li> 列表项
</ul>
无序列表
默认表现为小黑点，可以通过type属性改变
默认 type="disc"
小圆圈 type="circle"
小方块 type="square" 

<ol>
    <li></li>列表项
</ol>
有序列表
默认表现为123，可以通过type属性改变，还有start
常用属性:
type : 指定序号的类型,常见的有A,a,I,i
start : 从几开始,必须得写数字

<a></a>
超链接标签
常用属性：
href: 指定超连接网站:javascript:;点击后不会改变颜色
target: 以什么方式打开，即显示地方[结合框架使用可以将页面在框架中打开]
1._blank: 新页面打开
2._self: 默认原来页面打开
3.框架名称，跳转到某个已命名的框架中

<table></table>
表格标签
常用嵌套标签：
<tr>: 表示行
<td>: 表示列
<thead>: 表头
<tfoot>: 脚注
<tbody>: 表体
<th>: 表头行，自动加粗
<caption>:大标题，一般在table后面，就展示在表上方
常用属性：
border: 指定边框
width : 宽度
height : 高度
bgcolor : 背景颜色
align : 对齐方式
colspan : 跨列操作,合并n列
rowspan : 跨行操作
cellspadding:表格和内容的距离
cellspacing:表格之间的距离
    
```

### 1.2 使用HTML完成表单注册

```html
<form></form>
表单标签：为用户输入创建 HTML 表单
action：URL地址,表示页面即将跳转的地址
method：表示跳转方式
1，get, 默认提交方式，会将参数拼接在链接后面 , 有大小限制 ,4k
2，post, 会将参数封装在请求体中, 没有这样的限制，貌似需要网络
onsubmit：提交表单时触发，但是onclick比onsubmit更早的被触发。

【表单中常见标签】
（1）、<input> 
- label绑定input---for属性和input的id一致
  <label for="user">用户账号:</label>//label的for属性值
  <input type="text" placeholder="用户账号" id="user"/>//和id的的一致，点击label，输入框被选中
-  输入选项标签常见属性：
1、type: 指定输入项的类型
   普通框式：
	text : 文本
    password :  密码框
	tel     : 手机号
    number   : 只允许输入数字
	date    : 日期类型
   按钮式：
    radio :	 单选按钮  要实现单选效果必须加一个相同的name，保证唯一性：name="sex"
    checkbox :  可以单选，可以复选框。这两个还有一个属性，那就是是否预先选中，checked='true'
    file 	 : 上传文件
    submit   : 提交按钮  onclick点击事件
    button 	 : 普通按钮
    image    : 以图片为基础的按钮，需要加入一个src
    reset	 : 重置按钮
    hidden  : 隐藏域
    name : 在表单提交的时候,当作参数的名称
    textarea : 文本域, 可以输入一段文本 cols : 指定宽度、rows : 指定的是高度 wrap:是否自动换行
   下拉列表：
    select  : 下拉列表
    option : 选择项，还可以加一个size属性，设定下拉列表的行
2、id : 给输入项取一个名字, 以便于后期我们去找到它,并且操作它			
3、 placeholder : 指定默认的提示信息
（2）、<select></select>
下列列表标签
option : 选择项
multiple:展现长列表，出现滚动栏，可以多选

<framest></framest>
框架标签---后台、大纲跳转：点击左边的框架时，右边的框架会跳转
使用frameset要将body删掉,否则页面会有问题
rows,cols: 按列/行划分页面，选项为20%，20px（可以不带px，自动识别为像素，*（剩余部分
【框架中标签】
frame
常用属性：
src: 引入的html文件路径
name: 指定框架的名称，结合链接a标签target属性使用可以将框架跳转到页面

使用：
<framest rows='20%,200,*'>%将框架分为三部分，从上至下分别占20%，200px，和剩余的80%-200px
    <frame src='a.html' name='aaa'></frame>//这个框架显示a.html的内容，且此框架的名字设置为aaa
	<frame src='b.html' name='bbb'></frame>
	<frame src='b.html' name='ccc'></frame>
</framest>
在a.html中
<a src='name.html' target='bbb'>发送</a>//点击aaa框架中的发送链接，跳转到name.html中，且在bbb框架中显示
```

### 1.3 HTML中的某些实体字符集

| 结果   | 实体名称         |
| ------ | ---------------- |
| ""     | &quot ;     引号 |
| &      | & amp;     并号  |
| <      | & lt;            |
| >      | & gt;            |
| &copy; | &  copy;         |
| &reg;  | & reg;           |
| 空格   | & nbsp;          |

### 1.4 html5中新标签

音频和视频标签

| 方法                                                         | 描述                                      |
| :----------------------------------------------------------- | :---------------------------------------- |
| [addTextTrack()](https://www.runoob.com/tags/av-met-addtexttrack.html) | 向音频/视频添加新的文本轨道。             |
| [canPlayType()](https://www.runoob.com/tags/av-met-canplaytype.html) | 检测浏览器是否能播放指定的音频/视频类型。 |
| [load()](https://www.runoob.com/tags/av-met-load.html)       | 重新加载音频/视频元素。                   |
| [play()](https://www.runoob.com/tags/av-met-play.html)       | 开始播放音频/视频。                       |
| [pause()](https://www.runoob.com/tags/av-met-pause.html)     | 暂停当前播放的音频/视频。                 |

```
方法：load() play() pause()
事件：play() playing() pause() seeked() seeking() abort()当音频/视频的加载已放弃时触发
```

## 二.CSS

### 2.1 CSS入门

CSS概述:Cascading Style Sheets : 层叠样式表

主要作用:

​	美化我们的HTML页面

​	HTML 决定网页的骨架	,CSS  化妆

​	将页面的HTML和美化进行分离

简单语法:

​	在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中，最好分离开

### 2.2 CSS的使用

#### 2.21 **块标签**

- span标签可以包括在div标签中，但是div标签不能被包括在span标签中

```html
<div></div>
默认独占一段，自动换行
<span></span>
 内容显示在同一行
```

#### **2.22 CSS语法**

```html
<style>
    选择器{
        属性名称1:属性的值1;
        属性名称2:属性的值2;
    }
</style>
```

#### **2.23 CSS的选择器**

```html
id选择器: 通过id，以#开头
类选择器: 通过类名，以.开头
元素选择器: 通过标签名称
分组选择器: 通过一次性选择多个标签，逗号隔开
相邻选择器: 通过选择同级的标签，使用+号隔开
子选择器: 通过选择某个标签中子标签，>隔开，(只改变儿子)
后代选择器: 通过选择某个标签后代，空格隔开，和上面差不多，子标签下所有内容都会改变，如下的p span会改变span底下所有内容，即使不是span标签
 <span>
	 没有啦
	<span>还有这里</span>
    <b>这个呢？这么没原则吗？</b>
</span>
ps：且再定义span这个标签，不会改变上面后代
通配符选择器: 所以标签都会被设置，包括 body
伪类选择器: (a:hover) 通常都是用在A标签上
         link:未访问的链接
         visited:已访问的链接
         hover：鼠标移到到链接上
         active：选定的链接
属性选择器: 通过属性，如：a[name='name1']只选择a标签中name='name1'的

选择器的交并:
交集:黏在一起
并集:逗号分开
```

### **2.3 CSS的引入**

外部样式: 通过link标签引入一个外部的css文件

```html
<link rel="stylesheet" href="a.css" />
```

1、内部样式: 直接在style标签内编写CSS代码

2、行内样式: 直接在标签中添加一个style属性, 编写CSS样式

```html
<p style = 'background-color:red;width:200px'></p>
```

3、导入样式:使用@import导致链接

```html
@import 'a.css'
```

常用：外部引用

link和import的区别

```html
1、本质的差别：
link属于HTML标签，而@import完全是CSS提供的一种方式

2、加载顺序的差别：
当一个页面被加载时（或者被浏览者浏览时），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。
所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候会很明显。

3、兼容性的差别：
@import是CSS2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题

4、使用dom：
当使用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。
```

- **优先级：**

行内样式>id选择器>类选择器>元素选择器

就近原则：哪一个选择器里命令代码近，就使用，因为覆盖

### **2.4 CSS的浮动**

float：流式布局，正常块级元素都是占满父级元素的水平宽度，但是浮动后，元素位置确定，且宽度会收缩到足够包含所有内容，还会脱离标准文档流

1.文本环绕图片

普通做法：在图片中环绕文字，会出现3像素的距离，消除的方法

.img2{
		  	margin-left: -4px;
		  }

当folat：left时，不会出现

2.网页布局

```html
float属性:
left
right

clear属性: 清除浮动
both : 两边都不允许浮动
left: 左边不允许浮动
right : 右边不允许浮动
```

**影响：**浮动的元素会脱离正常的文档流，在正常的文档流中不占空间

**Q:**出现高度坍塌：

子容器的的浮动不占空间导致父容器高度坍塌，变成高度为0px

图片：

**R:**有四种常用解决方案，选择 **伪类**

```html
1,父容器添加
overflow: hidden; 浏览器自动检查浮动区域的高度
缺点:不能使用position

2,子容器添加空标签清除浮动
<div style="clear: both;"></div>
缺点:在项目中多

3,父容器添加
overflow: auto; 浏览器自动检查浮动区域的高度
缺点: 内部宽高超过父级div时出现滚动栏

4,定义伪类，在坍塌的容器里添加
.clearfix::before, .clearfix::after{
	content: "";  添加一个内容
	display: table; 转换为一个表格元素/块元素
}
.clearfix::after{
	clear: both; 清除
}
兼容低版本ie
.clearfix{
zoom:1;
}
作用：清除浮动，触发haslayout：计算自身及后代的尺寸和定位，解决margin重叠
```

### **2.5 CSS的盒子模型**

万物皆盒子，连body都是盒子，也有margin，所以设计页面需要对body设置CSS的margin属性。一个盒子，由内容(content)、内边距(padding)、外边距(margin)、边框(border)组成

图片：

```html
内边距：
padding-top：
paddiong-right:
padding-bottom:
padding-left:
写法：上右下左，顺时针
padding: 10px;  上下左右都是10px
padding: 10px 20px;  上下是10px 左右是20px
padding: 10px 20px 30px;  上 10px 右20px  下30px  左20px
padding: 10px 20px 30px 40px;  上右下左, 顺时针的方向

外边距：
margin-top:
margin-right:
margin-bottom:
margin-left: 

margin: 10px;  上下左右都是10px
margin: 10px 20px;  上下是10px 左右是20px
margin: 10px 20px 30px;  上 10px 右20px  下30px  左20px
margin: 10px 20px 30px 40px;  上右下左, 顺时针的方向

```

### **2.6 CSS的绝对定位和相对定位**

修改盒子的偏移，一定要开启定位

绝对定位--相对于最近的有position的**父标签**，最高为body，脱离文档流，仿佛不存在

position: absolute

​	top: 控制距离顶部的位置

​	left: 控制距离左边的位置

​	bottom：

​	right：

相对定位--相对于**父元素**，本身自己也是自己的参考物，仍在标准流中，不影响父、兄弟盒子的大小和位置

position: relative

```html
   .a{
      height: 400px;
      width: 400px;  //这里决定的父盒子的大小
      border: 1px solid pink;
      position: relative;  //使用relative，作为参照物
      top:20px   //相对于a原来的位置往下偏移20像素，并且不改变父盒子
    }
    .a1{
    	height: 200px;
    	width: 200px;
    	 border: 1px solid red;
    	 position: absolute; //使用absolute，找到最近的position，也就是a
    	 top: 20px;
    	 right: 30px;
    }
<div class="a">//这里是父标签a
		  <div class="a1">//子标签a1
		    我是a1
		  </div>
		  <div class="a2">//子标签a2
		    我是a2
		  </div>
</div>
```

### **2.7 CSS的常见属性**

详情见CSS参考手册

#### 2.71 position

```html
1，显示和定位：
position
选项：fixed(以窗口为参照物)/relative(自身作为参照物)/absolute(参照最新的position)
```
#### 2.72 float等布局
```html
2，布局
float:left,right,
clear:

display:设置对象如何显示
选项:none(隐藏对象)/block(块元素，相当于div)/table(块元素的表格)/flex(弹性盒子)/inline(行内元素，相当于span)
Flex是Flexible Box的缩写，意为"弹性布局"

visibility
选项:visible(可视)/hidden(隐藏)/collapse(隐藏表格的行和列)
与display不同，隐藏的属性仍有物理空间

overflow
选项：visible(溢出不处理)/hidden(溢出隐藏)/scroll(溢出滚动栏)/auto(自动，按需滚动栏)
```
#### 2.73 尺寸
```html
3，尺寸
width:
height:
margin:
padding:
```
#### 2.74 border等边框
```html
4，边框
border:(line-width,line-style,color)(边框宽度，边框样式，颜色)
border:1px solid red//使用
其中边框样式选项：border-style
none(无轮廓，width同时也会自动为0)/hidden(隐藏)/dotted(点状)/dashed(虚线边框)/solid(实线边框)/double(双线边框，宽度左右)

border-radius:圆角边框(length/percentage)(长度值设置圆角半径长度/百分比设置圆角半径长度)，常用长度值，可以设置1~4个值，从左上角开始，顺时针

boder-image:图像代替边框(boder-image-source,border-image-slice,border-image-width,border-image-repeat,border-image-outset)
(背景图片地址,切割图片,图片宽度,排列方式,向外扩张)

box-shadow:阴影环绕 (阴影类型/水平距离/垂直距离/阴影扩散程度/阴影尺寸/阴影颜色)
1,阴影类型：向外扩散，取inset就是内阴影
2，X-offset：水平偏移量，正值则阴影在对象右边，负值则左边
3，Y-offset：垂直偏移量，正值则阴影在对象底部，负值则顶部
4，阴影模糊半径：只能正值，0则没有模糊效果，值越大则越模糊
5，阴影扩散半径：正值，阴影扩大，负值，阴影缩小
6，多层阴影使用逗号隔开

属性值简写模式：
border-color: red green
上下边框为红色，左右边框为绿色
border-style:dotted dashed solid double
上右下左：顺时针
```
#### 2.75 background和color
```html
5，背景和颜色
background覆盖范围包括border，是包括width、border、 padding、margin

background属性
-image: url(链接)  背景图片填充 和平铺搭配使用，默认情况下纵横平铺

-repeat: 背景图片如何填充
选项 : repeat-x(沿水平方向平铺)/repeat-y(沿垂直方向平铺)/repeat(横纵平铺)/no-repeat(不平铺)/round(背景自动缩放到平铺)/space(相同间距平铺)
使用 : background: url(imge.jpg) no-repeat;

-attachment: 背景图像是否随对象固定
选项 : fixed(相对于窗体固定)/scroll(相对于元素固定)/local(相对于元素固定)

-position: 背景图像的位置
选项：center(横纵居中)/left(左中)/right(右中)/top(上中)/botom(下中)
同时，可以设定偏移量
right 20px bottom 20px --离右端20px，离底端20px
right bottom 20px      --从右开始填充，离底端20px
right 10px             --默认参数给top，从右开始填充，离顶端20px，所以在top和bottom中会出错

-origin: 位置计算开始点
选项: padding-box(从padding开始，包括padding)/border-box(从border开始，与前面就差一个border)/content-box(从content开始，与padding差一个内边距)

-size: 图片背景大小
选项: auto(真实大小)/cover(等比缩放，可能超过容器)/contain(始终在容器中)
同时，可以使用长度设定图片大小量
background-size: 200px  --图片为200*200
background-size: 200px 400px  --图片为200*400

-clip: 裁剪背景---约等于origin
选项: padding-box(从padding开始，不包括padding)/border-box(从border开始，不包括border)/content-box(从content开始)/text(文字开始)

-color: 当和背景一起时，图片覆盖颜色
     - 特殊颜色: background: transparent; --背景透明，等同于rgba(0,0,0,0)
     -背景渐变
        1,background:linear-gradient(to top/right/bottom/left,color,color);
        属性:默认从上至下;
            to top 从下至上
            to right 从左至右
            to bottom 从上至下
            to left 从右至左
        2,background: -webkit-linear-gradient(right,color,color)
        属性：从右到左，和上面反过来
      -color选项
        选项：balck等英文名/ #fff / rgba(0，0，0，0)分别代表Red、Green、Blue和 Alpha（不透明度）3个 0 时不是没有颜色，是黑色

传送门：将背景设计为两个嵌套，一左一右中间部分折叠起来，就可以改变整个背景框的长度，而不改变整体设计

opacity:不透明度，取值：0-1，0表示全透明，1表示完全不透明
```
#### 2.76 text和font
```html
6，文本字体
text-transform:文字转换
选项:uppercase(大写)/lowercase(小写)/capitalize(首字母大写)

text-align: 文字水平对齐
选项: start(对齐开始边线)/end(对齐结束边界)/left(左对齐)/right(右对齐)/center(居中)/justify(两端对齐)/match-parent()/justify-all(最后一行也两端对齐)
注意：长单词不自动断句，断长单词需要使用word-break，以及如果是两端对齐最后一行不会自动对齐

word-break:文本字内换行
选项: normal(按照亚洲和非亚洲规换行，大概是英文字母不换行)/keep-all(中日韩等都不允许换行)/break-all(允许换行)


text-align-last: 最后一行文字水平对齐
同文本对齐方式差不对，需要设置

text-justify: 文本对齐的方式

word-spacing: 单词之间间隙，原本没有空格的默认是同一个单词：例如：我很好hello是一个单词

letter-spacing: 字符间距，意思是每个字母都会有有间距：例如：hello 会变成 h e l l o

text-indent: 第一行的文本缩进
选项: each-line(强制换行也缩进)/hanging(反向被缩进的行)
text-indent:10em each-line;

vertical-align: 元素垂直对齐
选项：baseline(基线和父级盒子基线对齐)/sub(基线降到父级下标)/super(基线升到父级上标)/text-top(top对父top)/text-bottom(bottom对父bottom)/middle(垂直中心对齐x-中心)/top(top对top)/bottom(bottom对bottom)

line-height: 设置行高

font-size:

font-style: 设置文本字体样式
选项：ltalic(斜体，特殊不是)/oblique(全员斜体，连特殊也是)

font-family:设置字体
设计包含中文和空格，使用引号包围
可以多种字体，使用逗号隔开，其含义是，顺序查找，找不到就换下一个

font-weight: 设置字体加粗
选项: bold(700粗)/bolder(重)/lighter(轻) 取值是100-900，而且只能取整数
```
#### 2.77 text书写
```html
7，文本书写
text-decoration: (line,style,color)
text-decoration-line:修改线
选项: none(无装饰线)/underline(下划线)/overline(上划线)/line-through(贯穿线)/blink(闪烁,但是多数浏览器不支持)
text-decoration-color:修饰线的颜色
text-decoration-style:修饰线的形状
选项: solid(实现)/double(双线)/dotted(点线)/dashed(虚线)/wavy(波浪线)
text-decoration-skip:修饰线的略过内容
text-shadow: 参考box-shadow
```
#### 2.78 table和list
```html
8，表格和列表
list-style:(type,position,image)
list-style-image:url()
但是由于不同的浏览器项目图片和内容间距会不同，建议将ul中的type设置为none，然后设置li的背景为图片，统一间距

list-style-style:outside(文本以外)/inside(文本以内)
list-style-type:
常见:disc(实心圆)/cricle(空心圆)/square(小方块)/none/decimal(数字编号1.)

boder-collapse: 设置边框合并还是独立 separate(分离)/collapse(合并)
border-spacing: 边框独立时，分割距离 
empty-cells: 无内容时，是否隐藏边框(hide)/(show)

改变某一列
col标签，多少列多少个col，也是一个单行标签，可以写成:<col/>
```
#### 2.79 用户界面
```html
9，用户界面
text-overflow: 内容溢出时溢出部分处理
选项: clip(直接裁剪)/ellipsis(替换为...)
使用: 
    1,将溢出部分隐藏掉: overflow:hidden
    2,取消换行:white-space:nowrap
    3,设置:text-overflow:ellipsis

outline: 对象的线条轮廓，画在border外面，不占据布局空间，不能拆分为上下左右(width,style,color)
outline-offset:线条偏移量，正值是往border外扩展，负值是往border内缩
常用，输入框，按钮，点击时线条消失

cousor: 光标形状
选项:pointer(小手)/crosshair(十字线)/atuo(默认)/help(小问号)/e-resize(横向箭头)/wait(沙漏，圆，表)

zoom: 设置对象的缩放比例
常用：zoom:1

box-sizing: 设置盒模型的组成模式
选项: content-box(对象的实际宽度为width+border+padding)/border-box(对象的实际宽度为width)
box-sizing: border-box 为元素设定的宽度和高度决定了元素的边框盒。
	 把撑大的盒子缩回去

resize: 设置是否允许缩放，调节尺寸大小，对于所有被隐藏的元素
overflow:hidden(非visible)
选项: none(默认不行)/both(两边都行)/horizontal(宽度)/vertical(高度)

user-select: 设置是否允许用户选中文本
选项: none(不可选中)/text(双击或鼠标左按选择文本/默认)/all(点击即选中整个整体元素)/element(受边界范围限制)
```
#### 2.7-10 flew

- css中内联和外联:
  内联:写在当前html文件的css样式
  外联:css文件和html文件分离，将css单独写在一个.css文件中并导

弹性盒子的优点:
随着浏览器和窗口改变而改变

注意事项：flex子元素的设置float，clear，vertical-align属性都是没有用的。

```html
10，伸缩盒子
display: flex/inline-flex;  声明当前元素为伸缩盒容器*/
flew:
flex-direction:  声明布局方式对齐方式
选项:row()/row-reverse()/column()/column-reverse()
flex-wrap:  声明子元素是单行显示还是换行显示
选项:wrap() | nowarp() | wrap-reverse()
flex-flow属性是flex-direction和flex-wrap的缩写
justify-content: 水平方向子元素的对齐和分布方式
选项:flex-start | flex-end | center | space-between | space-around | space-evenly;
align-items: 子元素相对于flex容器在垂直方向上的对齐方式
选项: stretch | flex-start | flex-end | center | baseline;
align-content: 控制多行项目的对齐方式，如果项目只有一行则不起作用
选项: stretch | flex-start | center | space-between | space-around | space-evenly;
伸缩盒元素：
order:<integer>;    整数值，默认值是0    
flex-grow:1; 伸缩盒元素对于主轴上伸缩盒容器的剩余空间的分配 ，1表示占一份
flex-shrink:1; 对于亏损空间的抵扣（收缩），不支持负数*/
flex-basis:auto; 定义了在分配剩余空间之前元素的默认大小
flex:grow shrink basic;  速写模式
align-self: 控制单独某一个flex子元素的垂直对齐方式
选项: auto | flex-start | flex-end | center | baseline | stretch;
```
#### 2.7-11 transition
```html
11，变化和动画
transition: all 0.5s linear;
加入匀速变化效果
变化部分:width/height/all
变化时间:
变化速度:linear(匀速)/

animation:(name time type delay-time cricle 反向 时间之外)
animation-name:自定义一个名字
animation-duration:持续时间
animation-timing-function:变化速度
animation-delay:延迟时间
animation-iteration-count:循环次数
animation-direction:变化方向
选项:normal/reverse(反方向)/alternate(正反交替)/alternate-reverse(反正交替)

@keyframes
定义一个动画，不执行，交给animation执行
@keyframes line1{
	/*@keyframes
	 * 百分比来规定改变发生的时间，或者通过关键词 "from" 和 "to"，等价于 0% 和 100%。
	 * 在50%和100%时进行动画
	 * 50% 是动画的结束，100% 也是动画的结束时间。
	 */

	50%,100%{
	left:100%	
	}
}
```


#### 2.7-12 伪类选择器
```html
12，伪类选择器
E:nth-child(n){}
选择第N个子元素
E:frist-child{}
选择第1个子元素
E:only-child{}
选择只有一个子元素的元素
E::frist-letter
选择第一个字母

伪元素
E::before{}
在对象前插入一个内容，必须有一个content
E::after{}
在对象后插入一个内容，必须有一个content

伪类和伪元素的区别：
伪元素创建了一个脱离dom树的虚拟元素
伪类匹配指定状态的dom元素，满足一定逻辑
```

### 2.8 CSS的继承

根据后代选择器继承父类的属性的，但是有些属性是无法继承的

```html
h{
 color:red
}
em{
font-size:20px
}
<h>这个<em>还不错</em></h>
子元素也会是红色，但是父元素不会改变字体大小

也可以单独将子元素设置属性，例如嵌套的某一层
li li li{

}
找到第三层的li设置属性
```

### 2.9 层叠样式的概念

层叠的意思是覆盖，多层，即同一个组件，再不同时间可能有不同样式，本身具多个样式选择项。

### 2.10 CSS中的一些补充

- 颜色：红绿蓝三原色，都为0~255
  - 英文：red
  - 十六进制：#FFFFFF
  - rgb(a)：

- margin的覆盖
  - 两个元素如果是竖直排列的，margin并不会产生两次，例如p的margin设置为5px，那么上下两段间应是，上一段的下边距加下一段的上边距为10，但是其实只有5，若两段不一样的话，选择距离大的。
  - 两个元素如果是并列排列的，margin就是左边的margin-right加上右边的margin-left

- 标准文档流
  - 块级元素----拥有矩形区域，与兄弟竖直排列
  - 行内元素----没区域，并排排列，自动换行
  
- visibility: hidden和display: none 的不同:

  1、作用不同

  visibility: hidden----将元素隐藏，但是在网页中该占的位置还是占着。
  display: none----将元素的显示设为无，即在网页中不占任何的位置。

  2、使用后HTML元素有所不同

  visibility:hidden，使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。
  display:none，使用该属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”。
  
- BFC(block formatting context)

  形成条件：1，浮动元素，2，定位元素，3，display为inline-block和table-cell，table-caption，4，overflow除visible
  
  BFC的布局规则
  
  - 内部的Box会在垂直方向，一个接一个地放置。
  
  - Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
  
  - 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
  
  - BFC的区域不会与float box重叠。
  
  - BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
  
  - 计算BFC的高度时，浮动元素也参与计算。
  
- #### CSS Sprites

  1.简介

  CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。

  2.优点

  （1）CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；

  （2）CSS Sprites能减少图片的字节；

  （3）CSS Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率。

  （4）CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格。

  3.缺点

  （1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。

  （2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。

  （3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。

  （4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。
  
- a标签不能嵌套

  - 即设计和样式选择器都不能使用

- 主流浏览器内核私有属性css前缀：mozilla内核 (firefox,flock等)   -moz
                             webkit内核(safari,chrome等)  -webkit
                             opera内核(opera浏览器)     -o
                             trident内核(ie浏览器)        -ms

##  三、结合HTML和CSS常用功能

### 3.1 超链接按钮化

A：将超链接由行内元素改成块级元素

display:block

### 3.2 动画效果

A：

### 3.3 浮动和消除浮动

### 3.4 一个炫酷的按钮

折角流动，使用动画过渡、@keyframs

## 四.JavaScript

### JS概述

什么是javascript: JavaScript一种直译式脚本语言

什么是脚本语言?

​	java源代码 ----> 编译成.class文件 -----> java虚拟机中才能执行

​	脚本语言:   源码  ------- > 解释执行

js由我们的浏览器来解释执行

##### JS的组成:

<img src="D:\work\图片\js01.png" style="zoom: 67%;" />

ECMAScript : 核心部分 ,定义js的语法规范，语法，类型，语句，关键字，保留字，操作符，全局对象。

DOM: document Object Model 文档对象模型 , 一个应用编程接口(API)，主要是用来管理页面的，所有元素当成节点组织在一起，组成“DOM”树，可以任意删除、添加、替换、修改节点。例如一个默认html的DOM树为 ：

<img src="D:\work\图片\js02.png" style="zoom:80%;" />

BOM : Browser Object Model  浏览器对象模型, 控制浏览器显示页面之外的部分，移动、缩放、关闭、前进、后退、页面刷新、新窗口、地址栏、历史记录,、屏幕宽高和分辨率。

**HTML中使用JavaScript**

- scrpit的属性，外部引用标准只需1，4

  - 属性1：src：表示包含要执行的代码的外部文件。
  - 属性2：async：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
  - 属性3：defer：应该立即开始下载脚本，脚本可以延迟到文档完全被解析和显示之后再执行，但是对于脚本来说，需要按顺序下载。只对外部脚本文件有效。
  - type：代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。这个值始终都是"text/javascript"，

- script的使用

  - 1，直接在在HTML中嵌套，注意，在函数结束前不要出现字符串</script>,会被当成结束标签，例如：

    ```html
    <script>
     function sayScript() {
     console.log("</script>");
     }
    </script>
    如真需要用，需要将其转义，添加转义符“\”
    console.log("<\/script>");
        
    ```

  - 2，外部引用

    ```html
    <script src="example.js"></script>
    注意：不能因为它没有内容就写成单行标签
    <script src="example.js"/>
    但是在XHTML好像可以
    
    ps：script可以接受外部域的js文件
    <script src="http://www.somewhere.com/afile.js"></script>
    
    defer的使用：   <script defer src="example1.js"></script>
    async的使用：
    <script async src="example1.js"></script>
     <script async src="example2.js"></script> 
    标记为 async 的脚本并不保证能按照它们出现的次序执行，重点在于它们之间没有依赖关系
    ```

**js的位置**

放在head中意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到body的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在body元素中的页面内容后面。

##### JS的语法:

**简单语法**

- 变量弱类型: var i = true   可以是任意类型，若没有赋值则是undefined

- 变量、函数名还是操作符都区分大小写 

- 语句结束之后的分号 ，可以有，也可以没有，建议有

- 写在script标签

- 常用命名方式：首单词小写，其余单词首字母大写

- 关键字、保留字、true、false 和 null 不能作为标识符。

- 常用关键字：

break  do  in  typeof  case  else  instanceof  var

 catch  export  new  void  class  extends  return 

while  const  finally  super  with  continue  for  switch 

yield  debugger  function  this  default  if  throw  delete  import  try

**ES6语法**：

不再使用 var 而是使用 const 和 let

定义变量：let

定义常量：const，必须初始化，因为是常量

**原因**：没有块级作用域的限制

变量作用域：变量在什么范围可使用

使用var，作用域是函数作用域，let是块级作用域，基本上let的使用范围是var的子集，那么var实现不了的let肯定实现不了

let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError

```html
1，{} 块中
{
      var name = 'why';
      console.log(name);
 }
     console.log(name);

结果：都会打印,因为没有块级作用域限制，但是const不会修改

2，if 块
   if(true){
    var name = 'why';   
    var fun = function(){
       console.log(name);
     }
     fun; //错误示范，调用函数必须带小括号
     fun();
 }
    //这里修改了name，调用函数时,依然会改变name
   name = 'kobe'
    fun();
结果：第一遍打印是why，下面是kobe，因为没有块级作用域限制
对比：在const中，压根不能在作用域外使用，所以会报错，变量名重复

3，for 循环中
设立几个按钮
var btn =document.getElementsByTagName('button');
       for(var i = 0; i<btn.length;i++)         //没有用的部分></btn.length;i++)>
       {
        alert('i = '+i)//页面加载后，会弹出来五个框，分别是0-4
         btn[i].addEventListener('click',function(){
           alert('i = '+i)//响应函数执行后，弹出来一个框，无论点谁都是5
           console.log('第'+ i +'个按钮被点击了!');
         })
       }
                                    
结果：不论点击哪个按钮，都是第五个按钮被点击了
原因：for循环在页面加载完后立即执行，点击按钮才执行响应函数，在for循环里,i时一直变的,直到 i=5 退出循环,所以打印出来会是5，按钮响应常见失误
                                    
4，function函数
  function test(){
		    var a = "love";
//		    console.log(a)
		  }
		  test()
		  console.log(a)//输出错误，var的作用域是函数
   function test1(){
        let a1 = "love1";
//        console.log(a)
      }
      test1()
      console.log(a1)//更是
 不论是a还是a1都实现不了
                                    
                                    
5，作用提升
“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。
function foo() {
var age = 16;
var age = 26;
var age = 36;
console.log(age);
}
foo(); // 36

function foo() {
console.log(age);//用法：不声明的会保存到全局，这时age = 26，26也保存到全局了
var age = 26;
}
foo(); // undefined
但是let不会提升，
function foo() {
console.log(age); // ReferenceError：age 没有定义
let age = 26; 
}
foo(); //ReferenceError：age 没有定义

同时使用var和let声明同一个变量也会报错，它们只是指出变量在相关作用域如何存在。
var name;
let name; // SyntaxError
let age;
var age; // SyntaxError

6，全局声明
var name = 'Matt';
console.log(window.name); // 'Matt'
let age = 26;
console.log(window.age); // undefined
                                    
```

##### JS的数据类型:

- 6 种简单数据类型---字面量
  
  - string----字符串可以使用双引号（"）、 单引号（'）或反引号（`）标示，
  
    - 字符字面量：\n 换行 \t 制表 \b 退格 \r 回车 \f 换页 \\ \  反斜杠（\）
  
      \ \'  单引号（'），在字符串以单引号标示时使用，例如'He said, \'hey.\''
  
    \\" 双引号（"），在字符串以双引号标示时使用，例如"He said, \"hey.\""
  
  - number---数值
  
    - 比0大的最小数值保存在 Number.MIN_VALUE 中，最大数值保存在 Number.MAX_VALUE 
    - 比max值大的值称为无穷，就是infiniy，而它的负值就是-infiniy
    - NaN，意思是“不是数值”（Not a Number），例如0除以任何数，两个字符相乘，任何数和NaN做运算，返回值都为NaN
    - 其他进制：八进制和十六进制，0开头后面为小于8的数字，当做八进制，0x开头，当做十六进制，0b开头，为二进制。输出都会转化为实际输出
  
  - boolean---true 和 false
  
  - undefine---任何声明后但是没赋值的变量，但是在let中不能直接使用没声明的变量，因为let并不会提升
  
  - null---空指针对象，typeof会是object
  
  - Symbol （es6新增）
  
  - object----对象，前六种都是简单数据类型，这种是引用值

##### JS的运算符和语句:

- **数据转换**
  
  - （一）将数据强制转换为String
    - 1，调用toString()方法---调用x的y()方法：x.y()，该方法不会影响原变量，不适用于null和undefined（number，blooean，和string）
    - 2.调用String()函数，并将被调用的数据作为参数传入，和上面差不多，但是没类型限制
    - 3，加上一个空串''
  - （二）将数据强制转化为Number
  
    - 1,调用Number() 函数---将任意类型转化为数值，
      - 字符串转为数字---只要有非法数字就转化为NaN（弊端），纯数字才转化为数字，空字符串转化为0，
      - boolean转化为数字---true为1，false转为0
      - null转为数字----0
      - undefined转为数字----NaN
    -  2,调用parseInt()函数---专门用来对付字符串，匹配成整数，从非空字符开始匹配，遇到非加减号数值则返回，空字符串也会返回 NaN，"1234blue"会被转换为 1234，可以识别十六进制和八进制，传递数字进制，let num = parseInt("0xAF", 16);
    - 3,parseFloat()---匹配成浮点数，没十六进制，如果是非字符串使用这两个函数，则会先转化为字符串，再操作
    - -0 *1 /1
    - 一元运算符：a=+a
  - （三）将其他数据强制转换为boolean
    - 数字，只有0和NaN为false
    - 字符串，空串为false，连空格都是true
    - null，就是false
    - undefined，都是false
  - 做两次非运算
  
- **反引号的使用**---模板字面量

  - 可以换行，但是不同的换行方式，都会保留内部的空格，也就是字符串的长度

  - 字符串插值${ }的使用，所有插入的值都会使用 toString()强制转型为字符串

    - ```
      let value = 5;
      let exponent = 'second';
      let interpolatedString =
       value + ' to the ' + exponent + ' power is ' + (value * value); 传统
      ${ value } to the ${ exponent } power is ${ value * value } 模板字面量
      ```

- **运算符（操作符）**

  - typeof操作符---来确定任意变量的数据类型，以字符串返回

  - 算数运算符---会将非number的数据转化为number再做运算，+ - * / %（取模）

    - +：两个字符串相加，哪怕是数字，都会拼接。只要包含字符串，都会全部转化为字符串再操作拼串

    - ```html
      顺序的作用
      result1 = 1 + 2 + '3'
      result2 = '1' + 2 +3
      
      其中result1为 ‘33’
      result2为 ‘123’
      ```

    - -：减法会将字符串转为数字，只有加法是

  - 一元运算符----+和-

    - 运算符会将所有非数值数据先转化为数值类型，再做改变
    - 使用： a=+a  a=-a

  - 自增和自减----a++和++a,a--和--a

    - 唯一一个会直接反映到原变量上的，即a++，则a在自身基础上加1

    - 前自增和后自增的区别---先赋值和先自加

      - 前自增保存的是原变量新值，后自增保存的是原始值，即前自增优先运算，运算优先后自增，运算完依旧要执行自增

      - ```html
        a = 10
        a = a++ + ++a;
        转化为
        a = 10 (a=11) + 12 =22
        
        a = a++;
        a = 11
        a++ = 10
        a = 10
        
        a = ++a
        a = 11
        ++a = 11
        a = 11
        ```

  - 布尔逻辑运算符 --- ||（或） && （且） ！（非）

    - ！---基于boolean，将非boolean值转化为布尔
    - &&----不一定返回boolean值
      - 可返回null，undefined，NaN，number
      - 即两个都是true，返回后面的，即若第一个值为true，则返回第二个值
      - 两个都是false，则返回后面的，即若第一个值为false，则返回第一个值---原值
    - ||---同上，不一定返回boolean值
      - 第一个值为true，则必然返回第一个值
      - 第一个值为false，则必然返回第二个值

  - 赋值操作符

    - =   ----a=1
    - +=----a+=1:a=a+1
    - -=----a-=1:a=a-1
    - *=----a *=1:a=a *1
    - /=
    - %=

  - 关系运算符号

    - 大于>，小于<，大于等于>=，小于等于<=，转换为数值，根据结果返回boolean值，

      - 任何值和NaN比较都是false

      - 如果两边都是字符串，不会转换为数值，会比较两边的Unicode编码，一位一位进行比较

      - ```html
        'a'<'b'
        返回true，因为a的unicode为8092，而b的unicode为8088
        
                                                    
        在字符串中使用转义符输出unicode编码
        \u四位编码
        例如：
        "\u0031" （十六进制
        
        在body页面使用
        &#编码; （十进制，需要将unicode编码转化为十进制
        ```

  - 相等操作符

    - 等于、不等于 ==   ！=
    
      - 返回boolean值
    
      - == 和！=比较两个值时，若两个值类型不同，则会转化为相同的类型
    
      - ```html
        不一定全转为number
        true == 'hello'//flase,看起来应该是都转为number
        
        null == 0//false,这个null就没有转为number
        
        undefined == null//true,undefined衍生于null，所义会返回true
        
        NaN不和任何值相等，包括 NaN 本身在内的任何值：
        NaN == NaN// false
        因此衍生出专门判断NaN的函数
        isNaN()
        ```
    
    - 全等和不全等  ===和！==
      - 全等需要相同类型，否则直接返回false
      - 不全的等也需要相同类型，不然直接返回true

  - 条件运算符（三元运算符）
    
    - 条件表达式？语句1：语句2；
    
  - 运算符的优先级
    - ，运算符，同时声明多个变量并赋值
    - 先乘除再加减
    - 常用&&>||，可以通过套括号的行为，改变优先级顺序，因为括号优先级很高
    
  - 高级数学操作符

    - 指数操作符号---Math.pow(底数，指数)   或底数  ** 指数
    - 平方根操作符-----Math.sqrt()
    - 

- **语句**

  - 每一条都是语句
  - {}称为代码块，只有分组作用，一同执行或不执行，在代码块后不需要分号

##### 流程控制语句--if&while&for

- 条件判断语句（if）、条件分支语句（switch）、循环语句（for，while，do...while）

  - if----if-else/if...else if...else

  - switch---需要全等

    - ```html
      switch(条件表达式){
      case 表达式:
      语句
      break;//否则下面的都会实现
      case 表达式:
      语句
      break;
      case 表达式:
      语句
      break
      ...
      default:
      语句
      break;
      }
      条件表达式和表达式作比较，相等则返回case下的语句，所有条件表达式常用true
      
      当满足多个条件执行同样的代码，可以
      case 1:
      case 2:
      case 2:
      语句
      ```

  - while

    - while(条件表达式){...}-----先判断条件，再执行代码块，常用break跳出循环

      - ```html
        三步走：
        1，初始化一个变量
        var i = 0 
        2，循环中设置条件表达式
        while(i > 10)
        {
            3,定义一个更行表达式，每次更新初始化变量
        	i++
        }
        ```

  - do-while
    - ```html
      do{
      	语句
      }while(条件表达式)
      
      于while的区别，先执行循环体，也就是条件表达式无论是否满足都会执行一次
      ```
    
  - for

    - ```html
      1,初始化表达式
      2，条件表达式
      3，更新表达式
      for(初始化表达式; 条件表达式;更新表达式){
      
      }
      
      执行流程：
          1初始化表达式
      	2执行条件表达式，判断是否执行
      	3执行循环语句
      	4更新表达式，更新完毕继续重复执行2
      ```

  - break和continue

    - break---常用来switch跳出

    - continue用来跳过当次循环，braek跳出整个循环

    - 不能在if语句中使用break或continue

    - break和continue循环只影响离它最近的循环，若想跳出父循环，则需要使用标签语句

      ```html
      标签语句：
      label：satatment
      例如：
      outer：for{
      for{
      break outer；//这样就结束指定的循环了
      }
      }
      ```

- 计时器

  - 通过console.time()开启计时器，里面有参数给计时器起名字'test'
  - 通过console.timeEnd(’test‘)   46

- for-of 语句---于遍历可迭代对象的元素

  - ```html
    for (const el of [2,4,6,8]) {
     document.write(el);
    }
    ```

##### JS中的对象---复合型数据类型

- 前面基本讲了基本数据类型（Number，Boolean，String，Null，Undefined）以及运算使用，本节主要讲最后一种Object

- 对象分类

  - 1，内建对象:

    - 数组---区别，属性改为索引

      ```html
      1，构造函数创建数组
      - var arr = new Array(10)//可以传入参数，表示长度，new可省
      - arr[0] = '罗雨凤',//索引值为0
      - arr[1] = '周舟'//索引值为0
      - consle.log(arr)//['罗雨凤','周舟']
      - consle.log(arr[3])//根据索引值访问数组元素，超出索引返回undefined
      - arr.length//数值长度属性，返回最大索引+1，可以修改
      - arr[arr.length]=10//可以向数组最后添加一个属性
      
      2，字面量方式创建数组
      var a = [1,2,3]//可以直接添加元素
      var a = new Array(1,2,3)//构造函数也可以直接添加元素
      区别---只传一个元素时：
      var a =[10]//创建一个只要一个元素10的数组
      var a = new Array(10)//这里的10是长度
      
      3，数组里的方法
       - push()--向数组末尾添加一个、多个元素，并返回新数组的长度
      var result = arr.push("nihao","wohenhao")//result存储数组新长度，此时这两个元素已经被添加
      
       - pop()--删除并返回最后一个元素
      var result = arr.pop()//result存储wohenhao，此时wohenhao已经被删除了
      
       - unshift()--往数组前添加元素并返回新的数组长度
      
       - shift()--删除并返回第一个元素
      
       - forEach()--遍历数组的方法，需要传入一个函数作为参数
         - 我们创建，但是不需要自己调用，称为回调函数。例如下面的匿名函数
      arr.forEach(function(a){//数组中有几个元素，这个函数就自动回调几次，每次执行，浏览器会将遍历的元素以实参的形式传入，可以定义形参a读取
      	console.log(a)//这个a就是数组元素
      })	
         - 这个参数并不是唯一的，可以传入三个参数
            - 1，当前的元素
      	  - 2，当前的索引
      	  - 3，就是整个数组
      
       - slice()--从数组中返回指定的某个元素
      arr.slice(0,2)//第一个参数0时开始位置，包括0，2是结尾位置，不包括，最终返回['luoyuf','nihao']
      arr.slice(2)//只传入一个元素，就是从2开始截到最后
      arr.slice(0,-2)//索引可以传递一个负值，则从后往前计算,即0到倒数第三个
      
       - splice()--删除数组中的指定元素，将被删除的元素作为数组返回，会影响原数组
      var result = arr.splice(0,2)//将原数组中的['luoyuf','nihao']删除，同时，result的结果为['luoyuf','nihao']
      //第一个参数表示开始位置的索引
      //第二个参数表示删除的数量
      //第三个及以后，可以传递新的元素，自动插入到开始位置的索引
      arr.splice(0,2,'没用','啊？','是吧')//arr变成['没用','啊？','是吧','wohenhao']
      
      - concat()--连接两个或多个数组，还可以传元素，并且返回新数组，不会影响数组
      var arr = arr1.conact(arr2,arr3,'你好啊')//arr1后面连接arr2，再连接arr3，再连接'你好啊'并返回
      
      - join()--将数组变成字符串并返回，中间以逗号隔开，不会影响原数组，参数表示连接符，什么都可以
        var arr = arr.join(-)//输出'你好啊-我很好'
      
      - reverse()--反转顺序，直接修改原数组
        arr.reverse()//arr输出[我很好，你好啊]
      
      - sort()--将数组排序，直接修改原数组，按照unicode编码排序，纯数字也是
        arr = [2,5,11,8,3]
        arr.sort()//输出[11,2,3,5,8],因为unicode一位一位比，比第一位，1在所有前面
        自定义排序方式---添加一个回调函数，回调函数有两个参数，不确定是数组里的谁，但是确定左边的参数在右边参数前面，并且回调函数根据返回值交换顺序，>0交换，<=0不交换  ></不交换>(return a-b)
      
      ```
    
  - Date对象---表示时间
  
    ```html
      var d = new Date();//d为当前代码执行的时间
      
       - 创建一个指定的日期
         - 输入一个字符串作为参数
         - 这个字符串的格式：月份/日/年份 时：分：秒
      var d = new Date('12/03/2017 12:20:40')
      
      Date中的方法
      1，getDate()--返回日期中的日
    2，getDay()--返回日期中的周几：0-6，0代表周末
    3，getMonth()--返回日期中的月份：0-11，0代表一月
      4，getFullYear()--返回完整年份，此外，时，分，秒，毫秒都可以
    5，getTime()--返回时间戳，从格林威治标准时间1970年1月1日0时0分0秒到现在日期所花费的毫秒数
      6，Date.now()--返回当前的时间戳
    ```
    
  
    - Math对象---数学运算对象，但是不是一个构造函数，只是一个工具类对象，所以不用创建，直接使用

      ```html
      1,Math.PI----表示派
      2，Math.abs()---表示一个绝对值
      3，Math.ceil()---表示向上取整
      4，Math.floor()---向下取整
      5，Math.round()---四舍五入取整
      6，Math.random()---生成一个0-1的随机数，不包括0和1
      7，Math.max()---表示几个数中最大的数
      8，Math.max(x,y)---表示x的y次幂
      ```
  
      
  
  - 2，宿主对象：BOM,DOM
  
  - 3，自建对象：自已创建的对象
  
    ```html
    创建对象
    var obj = new Object()
    1，其中，使用new关键字调用的函数，是构造函数，构造函数是专门用来创建对象的函数
    
    2，在对象中保存的值称为属性:对象名.属性名 = 属性值
    obj.name = 'luo'
    
    3，读取属性，若读取到没有的属性，则会返回undefined，而不会报错
    
    4，修改
    
    5，删除属性
    delete obj.name
    
    6,属性名起名规范:不强制要求遵守标识符的规范，什么东西都可以用，例如var，true，变量
       但是起名方式改变了:对象["属性名"] = 属性值 ，读取也需要遵守这个规则
    
    ```
  
  7,属性值可以是任意的数据类型，包括对象
  
    8,检查对象中是否含有某对象: "属性名" in 对象，有则返回true，无则返回false
  
    使用对象字面量来创建一个对象：对象名 = {}
    var obj = {}
    可以直接指定对象中的属性
    var obj = {属性名:"属性值",属性名:"属性值"}
    名值对，使用: 号链接，最后一个最好不写,
  
  
    当在页面上打印对象时，出现"[Object Object]"
    这是因为时事实上是输出对象的toString()方法的返回值
    console.log(obj == obj.toString())//返回true
    这个toString是Object的属性，在对象，或者对象的原型添加toString属性，都可以修改输出
  
    9，对象的字面量增强写法
    var name = 'luo'
    var obj = { name:name}//用上面的name给name属性赋值
    var obj = { name }//和上面等价
    ```
    
    
    ```


##### JS的基本变量和引用变量

1. 引用值和原始值
   - 原始值：null,number，boolean，string，symbol，undefined
   - 引用值，包含很多属性的对象，object，可以动态的添加属性
   
2. 复制的区别----栈内存和堆内存
   - 原始值，基本数据类型在栈内存中存储，值与值相互独立。复制内容，创建副本
   - 引用值，保存到堆内存，在堆内存中开辟空间给对象使用，而栈内存保存的是对象的内存地址。指向同一个地址，修改一个属性，两个都改变
   
3. 参数传递
   - 原始值：形参的意义：将这个变量作为参数传入函数，并不会改变这个变量，而函数的参数是局部变量
   - 引用值：也会改变传入参数的值
   
4. 参数类型
   - 原始值：使用typeof
   - 引用变量：已知是object，确定是哪种类型的：
   
5. 全局上下文---window对象，通过 var 定 义的全局变量和函数都会成为 window 对象的属性和方法，但是使用 let 和 const 的顶级声明不会定义在全局上下文

6. 比较变量

   - 基本类型，比较值，长的一样的话会相等
   - 引用类型，比较保存地址，长的一样不会相等，因为保存的地址不同


##### JS的输出

- alert()  直接弹框
- document.write()  向页面输出
- console.log() 向控制台输出
- innerHTML:  向页面输出
- prompt:弹出一个框，还带输入框，可以输入内容，输入的内容会作为返回值返回，返回值是String类型的
- comfirm：弹出一个校验框，确定返回true，取消返回false

##### JS的函数

- 函数也是一个对象，document，console都是对象。

```html
1,使用构造函数创建函数，将代码封装到函数中,以字符串形式
var fun = new Function()
1.1,typeof 检查会返回function
1.2，使用时需要调用函数: fun()


2，使用函数声明来创建函数
function 函数名(形参1，形参2，...){
语句...
}

3，函数表达式来创建函数
var 函数名 = function(形参1，形参2，...){
语句...
}

4,函数的参数
  形参不传入，不会报错，会自动设为undefined
  参数传入超过，自动忽略
  参数少于，少的也是自动undefined

5，return返回值
return作为函数返回值，同样也是函数结束的地方，return下面的语句不会执行
可以定义一个变量接收它
函数{ return a;}
var result = 函数名()//result为a
return后可以跟任意类型值，return也可以不跟值，相当于返回undefined，也可以不写return也是undefined

6，形参和实参
实参可以是任意类型（对象，函数）当传递参数过多，可以将参数封装到一个对象中，通过对象传递

7，fun()和fun的区别
fun() 是调用函数，即函数返回值
fun   是函数对象
例子：
fun1(){
fun2(){}
return fun2;//返回函数fun2对象
}
a = fun1()//即是函数fun2对象
a()//相当于在调用fun2
fun1()()//等同于上面两条

8，匿名函数
function(){}
会报错，因为它把{}当做整体，而不是把整个函数当做整体，需要用括号括起来
(function(){})

9，立即执行函数
(匿名函数)()//没有使用变量接收函数对象，所以可以加()立即调用，缺点是即用即无

10，方法
函数也可以作为对象的属性，此时称这个函数为这个对象的方法
obj.sayName = function(){}//此时obj的sayName属性是一个匿名函数
obj.sayName;//这里是函数
obj.sayName();//这里就调用了函数

11，Object.keys(obj)//遍历对象中的属性名

12，过滤器filter
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
filter() 不会对空数组进行检测。filter() 不会改变原始数组
语法：array.filter(function(currentValue,index,arr), thisValue)
- 参数一：函数。是必须的，函数里的参数一也是必须的，表示当前遍历的数组项
- 参数二：可选
 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        let newArr = arr.filter((item, i, arr) => {
            //函数本身返回布尔值，只有当返回值为true时，当前项存入新数组。
            return item % 2 == 0
        })
        console.log(newArr)


13,number的方法：保留几位小数.Tofixd
num = num.toFixed(2);//第二位小数也是四舍五入
```

- 遍历：for-in 和 for-of

```html
for-in遍历数组的索引，包括元素和属性和方法---语法：for(var 变量 in 对象){}
for-of遍历数组的元素值---语法：for(var 变量 of 对象){}

var myArray = [11,22,33]
myArray.name = '你好啊'
for (const n in myArray) {
  alert(n);//0,1,2,name
 alert(myArray[n]);//11，22，33，'你好啊'
}
for (const n of myArray) {
 alert(n);//11,22,33
}
for...in语句中，对象有几个属性，循环就会执行几次，每次都将对象的属性名按从上到下的顺序赋值给变量n,对于数组，索引值也是属性名

 
代替遍历   in
          for(let i in this.books)
         {
            result += this.books[i].price;
          }
 三:进阶写法,舍去下标,直接就在数组里的块  of
             for(let book of this.books)
            {
              result += book.price;
            }
```

- 函数的this关键字

  - 解析器调用时向函数内部传入的一个隐含参数，称为this，指向一个对象，称为函数执行的上下文对象，根据函数**调用方式**的不同，this指向不同的对象

    1. 以函数的形式调用，this永远时window
    2. 以方法调用，this就是调用方法的那个对象

  - ```html
    工厂方法创建对象---类似于Java的构造方法
    function fun(name,age){
    var obj = Object();
    obj.name = name;
    obj.age = age;
    obj.sayName = function(){
    	console.log(this.name)//this指的是调用函数的那个对象
    };
    return obj;
    }
    var obj1 = fun("罗雨凤",20)
    var obj2 = fun("叶惠美",50)
    obj1，sayName()
    
    构造函数----因为使用工厂方法创建的对象，都是object类型，无法区分多个不同类型的对象，例如一个信息，分不清是狗还是人
        习惯首字母大写
        构造函数调用方法：使用new关键字
        var per = new Person()
        构造函数的执行步骤：
        1，new关键字立即创建一个对象，所以per是对象
        2，将新建的对象per设置为Person()的this，在构造函数中，可以使用this来引用新建的对象
        3，执行Person()的代码
        4，将这个对象返回，所以per是一个对象，而不管Person()有没有返回值
    ```

    ```html
    构造函数中this的使用
    function fun(name,age){
    //无需声明对象，因为构造方法已经有一个对象，而且时本函数的this
    this.name = name;//等同于obj1.name = "罗雨凤"
    this.age = age;//等同于obj1.age = 20
    }
    var obj1 = new fun("罗雨凤",20)
    var obj2 = new fun("叶惠美",50)
    这些使用同一个构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类，由它创建出来的对象称为实例
    使用instanceof检查一个对象是否是一个类的实例
    对象 instanceof 类/构造函数
    Object是所有对象的祖先，所有对象和Object做instanceof检验，都会返回true
    
    构造函数的方法共享性---函数即用即毁的特质，导致不同的实例的方法是独立的，每执行一次都会创建一个新的方法
    可以使所有对象共享一个方法,将函数分离到全局作用域中
     function fun(name,age){
            var obj = Object();
            obj.name = name;
            obj.age = age;
            obj.sayName = func//自身没,找全局变量，全局变量的地址和值不会改变
            return obj;
            }
            var func = function(){
              console.log(this.name)//this指的是调用函数的那个对象
            };
            var obj1 = fun("罗雨凤",20)
            var obj2 = fun("叶惠美",50)
            console.log(obj1.sayName == obj2.sayName)//返回了true
    
    原型变量---因为将函数方法放在全局作用域不安全，污染全局变量，放在全局，但是只供给函数用
    每一个函数都有一个唯一的对象属性名为原型（prototype）
    1，如果是普通函数调用，原型没任何作用
    var obj1 = fun("罗雨凤",20)
    var obj2 = fun("叶惠美",50)
    obj1.prototype == obj2.prototype//同一个函数的调用返回true
    fun1.prototype == fun2.prototype//不同函数的原型返回false，因为是唯一的
    数组也有原型，而且也是数组
    
     2，当函数通过构造函数调用时，所创建的对象都会有一个隐含属性，指向原型对象
        访问该属性：__proto__
        var obj1 = new fun()
        obj1.__proto__ == fun.prototype//返回true
        原型相当于是一个公共区域，可供给任一函数实例使用，可以将对象中共有的内容，统一设置到原型对象中
        fun.prototype.a == 123//obj1.a = 123
        在prototype中添加的属性a，若obj1在自身找不到，就会去原型找，所以就会等于123
        即对象中不包括的属性，但是原型里有，属性检查也会返回true
        "a" in obj1 //返回true
        那么如何检查对象本身的属性，使用hasOwnProperty()
        boj1.hasOwnProperty('a')//返回false
    
    ```

  使用原型变量  修改 构造方法的共享属性：
    function fun(name,age){
            this.name = name;
            this.age = age;
            }
           fun.prototype.sayName = function(){
           console.log(this.name);
           }
            var obj1 = new fun("罗雨凤",20)
            var obj2 = new fun("叶惠美",50)
            console.log(obj1.sayName == obj2.sayName)//返回了true

     3，原型对象里，也有原型对象，所以
     找一个属性，先在本身寻找，再去原型找，原型里找不到，则去原型的原型里找
     obj1.__proto__.hasOwnProperty("hasOwnProperty")//返回false，证明hasOwnProperty属性不在原型对象中
      obj1.__proto__.__proto__.hasOwnProperty("hasOwnProperty")//返回true，证明hasOwnProperty属性在原型对象的原型对象中
    直到找到Object对象的原型，Object对象没原型属性，找不到就返回undefined
    obj1.__proto__.__proto__.__proto__//是null

    ```
  
    ```

- 另一个隐含参数--arguments，封装实参的对象，类数组对象，并不是数组，只是类似。可以使用length，和使用索引

  - ```html
    fun(){//这里没有定义形参，也可以使用arguments,因为它保存实参
    console.log(arguments.length)//输出2
    console.log(arguments[0])//输出"hello"
    }
    fun('hello',true)//传入两个实参
    
    
    callee--arguments中的属性，指向当前数的对象
    arguments == fun//输出true
    ```

  - 函数的方法

    - -call()和apply()--当对函数使用这两个个方法时，函数都会被调用
    
    ```
    第一个参数若是对象，则就是函数的this
    call()--对象之后，依次传入函数的实参
    apply()--对象之后，将实参封装到数组中传入函数中
    
    this的用法
    1，使用函数调用，this就是window
    2，使用方法调用，this就是调用方法的对象
    3，构造函数，就是新建(new)的那个对象
    4，call和apply，this就是第一个参数指定的那个对象
     
    ```

##### JS作用域与内存

作用域链---变量的作用域创建作用域链，能否使用变量依靠作用域链决定

- 全局作用域，编写在script标签下，页面打开时创建，关闭时销毁，创建的变量都在全局对象window（浏览器创建的最高层）中可以使用，作为window的属性，创建的函数作为window的方法保存

  ```html
  变量声明提升
  console.log(a)//undefined  不会报错，使用var声明了全局变量，会提升至顶部
  var a = 10//let和const或不声明则不会提升
  等同于下面的代码
  var a
  console.log(a)
  a = 10
  
  函数声明提升
  fun2()//会报错
  fun1()//不会报错
  function fun1(){}
  var fun2 = function(){}//后面是一个表达式，将这个表达式赋值给前面的变量，所以终归还是变量
  fun1是使用函数声明形式的函数，这种优先于其他变量，会在最开始就执行其他代码前就创建，所以在声明前调用
  fun2是函数表达式形式的函数，不会声明提前
  
  ```

- 函数作用域，调用函数时创建，函数执行完毕后销毁，每调用一次就会创建新的函数作用域，相互独立，在函数作用域中可以访问全局作用域中的变量，在全局作用域中无法访问函数作用域的变量

  - 函数作用域使用一个变量时，先在自身作用域寻找，有就使用，无就往上一级作用域（无嵌套函数就是全局作用域）找。

  - 在函数作用域中使用全局变量可以使用window对象

  - 在函数作用域中也有声明提前的，使用var声明的变量会在函数中所有代码执行前被声明，函数声明也会提升

  - 在函数中，不使用var声明的变量一旦函数被调用都会自动到全局变量

    ```html
    var a = 10
    function fun(){
    console,log(a)//可以访问全局，输出10
    a = 20//这里没用var声明，是全局变量a，改变了全局变量
    
    console.log(b)//报错，因为是一个没声明的变量
    b = 30//全局变量
    
    console.log(c)//声明提前，输出undefined
    var c = 40
    }
    fun()
    console.log(a)//输出20
    console.log(b)//输出30
    console.log(c)//报错，全局访问不到函数作用域的变量
    
    
    形参对变量的影响
    var a =100
    function fun(a){//传入了一个var a = undefined
    console.log(a)//输出一个undefined
    a=10//相当于改变函数参数
    }
    fun()//没有传入变量，相当于未定义，undefined
    console.log(a)//a = 100
    ```

- debug断点调试

  - 在sources中，左侧点击断点，刷新，给变量右键添加监听（add ，f10下一步，在watch查看变量的作用域和值
  
- 包装类--前面学了基本变量和引用变量，这个是可以将基本变量转换为引用变量，不适用

  ```html
  - String()---将基本数据类型的字符串转换为String对象
  var str = new String("luo")
  typeof str//返回object
  
  - Number()---将基本数据类型的数值转换为Number对象
  var num = new Number(3)
  typeof num//返回object
  
  - Boolean()---将基本数据类型的布尔值转换为Boolean对象
  var boo = new Boolean(true)
  typeof boo//返回object
  ```

  ```html
  String字符串对象方法---大部分方法不影响原数组
  1，字符串在底层是以数组保存的，拥有length，索引等属性
  2，charAt(x)---返回指定位置（x）的字符
  3，charCodeAt(x)---返回指定位置字符的unicode编码
  4，formCharCode()---返回字符编码转为字符
  5，concat()---连接字符串
  6，indexOf('e',1)---检索字符串是否有指定内容,有则返回此字符所在的位置，无则返回-1,第二参数表明开始查找位置，表明从第二个字符开始查找
  7，lastIndexOf()---同上，不过从后往前找
  8，slice()---截取字符，同数组
  9，substring()---类似slice，但是不能接受负值，默认为0，若第二个参数小于第一个，自动交换顺序
  10，substr()---第二个参数是长度
  11，split(',')---将字符串拆分为一个数组，传入一个参数作为拆分的依据，这个就是遇到逗号就拆分为数组的一个元素，传空串则每个都转为一个元素
  12，toUpperCase()---将字符串转化为大写
  13，toLowerCase()---将字符串转为为大写---85
  ```

- 正则表达式----定义一些字符串的规则，校验是否符合规则

  ```html
  var reg = new RegExp('正则表达式','匹配模式');//创建正则表达式的对象
  typeof reg;//返回object
  //正则表达式的方法：test()---符合则返回true，不符合就返回false 
  
  var reg = new RegExp('a');//检查一个字符串是否含有'a',严格区分大小写
  var  str = 'a'
  var result = reg.test(str)//返回true
  
  //在构造函数中，匹配模式作为第二个参数，选项：
  i---忽略大小写
  g---全局匹配模式
  
  var reg = new RegExp('A',i);//检查一个字符串是否含有'a',不区分大小写
  var  str = 'a'
  var result = reg.test(str)//返回true
  ```

  ```html
  字面量来创建正则表达式
  语法： var 变量 = /正则表达式/匹配模式
  var reg = /a/i // /a/ig合法
  //可以同时设置多个匹配模式，且顺序无关
  
  //检查一个字符串是否含有a或b，使用|表示或者，[]也表示或者
  reg = /a|b/;    //a|b ==[ab]
  
  //检查一个字符串是否含有字母
  reg = /[a-z]/  //任意小于的字母，[A-Z]//任意的大写字母，[A-z]//任意字母
  reg.test('h')//返回true
  
  //检查字母串，中间不同
  reg = /a[bde]c/ //则abc，adc，aec都返回true
  
  //[^ ]除了
  reg = /[^ab]/ //只有a有b都不行，abc可以，因为除了ab还有其他
  
  //[0-9]任意数字
  reg = /[0-9]/ //包括任意数字
  reg = /[^0-9]/ // 不包括数字
  ```

  ```html
  正则表达式的方法
  - split()---将字符串拆分为一个数组
  //根据任意字母去拆分字符串，可以传递一个正则表达式作为参数，会根据正则表达式拆分字符串
  var result = str.split(/[A-z]/) //这个方法就会拆掉全局的字符串，加不加g都一样
  
  - search()---搜索指定内容，返回位置，没搜到就返回-1，也可以传递正则表达式
  var result = str.search(/a[bef]c/) //search反过来，哪怕设置了全局，依然会只查找第一个
  
  - match()---根据正则表达式将字符串中符合条件的内容提取出来，找到第一个符合的内容，并且返回
  = str.match(/[A-z]/g) //全局就返回所有匹配的内容，并且封装到一个数组中
  
  - replace()---将字符串替换，两个参数，一是被替换的内容，二是新的内容
  = str.replace('a','@')//只替换第一个出现的‘a’
  = str.replace(/a/g,'@')//正则表达式，并且可以替换所有‘a’
  
  ```

  ```html
  量词---设置一个内容出现的次数
   - {n} 正好出现三次，只对前面的第一个数作用
  /ba{3}/  //等同于baaa
   - {n,m} 出现n到m次
   - {n,} n次以上
   - + 至少一次，相当于{1，}
   - * 0个或多个，相当于{0，}
   - ？ 0个1个，相当于{0，1}
   - ^a 表示开头，就紧跟着a，对电话号码等很有用
   - a$ 表示结尾，a后面没有东西了
  - 特例： reg = /^a$/ //表示以a开头，同样开头后立即跟着结尾，所有只能是a，不能是aa
  
  检查一个号码是不是手机号
  规则：1，以 1 开头，
       2，一共十一位
       3，第二位的取值范围是3-9
       4，三位至11位任意数字
  var phoneNumber = /^1[3-9][0-9]{9}$/
  ```

  ```html
  /./   //正则表达式中.表示任意字符
  转义字符：\.  表示 .
          \\   表示\
  在构造函数中创建正则表达式，因为也会转义，所以要使用\\表示\
  var reg = new RegExp('\\.') //这样会变成正则表达式\\.\
  
  \w---任意数字、字母、_ == [A-z0-9_]
  \W---除了数字、字母、_ == [^A-z0-9_]
  \d---任意数字 == [0-9] 
  \D---除了数组 == [^0-9]
  \s---空格
  \S---除了空格
  \b---单词边界，也就是单词边界没有内容，是独立的
  \B---
  
  去除字符窜前后的空格
  str = str.replace(/^\s*/,'') //去除字符串前面的空格，不能省略*而写g，因为只有第一个空格是开头
  str = str.replace(/\s*$/,'') //去除字符串后面的空格
  str = str.replace(/^\s*|\s*$/g,'')//去除前后的空格
  ```

  ```html
  邮件格式：
  	1，任意字母下划线数字 . 任意字母下划线数字 @ 任意字母数字 .任意字母(2-5位) .任意字母(2-5位)
      /^w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/
  
  取两位小数：
  /^(\d{1}|[1-9]\d+)(\.\d{0,2})?/
  Number(15.7784514000.toString().match(/^(\d{1}|[1-9]\d+)(\.\d{0,2})?/))
  ```

##### JS垃圾回收

- GC----当一个对象，没一个任何对象和属性对它进行引用，永远无法操作，称为垃圾

##### 宿主对象----DOM文档对象模型

D--document：文档，整个html网页文档

O--object：对象，将网页中每个部分都转变为对象

M--model：模型，表示对象之间的关系，就是节点树节点之间的关系

**节点：**网页中的每一个部分都是节点，包括文档本身

​	1，文档节点---整个html文档

​	2，元素节点---html标签

​	3，属性节点---元素的属性

​	4，文本节点---标签中的文本内容

```html
document---浏览器自带的文档节点（window的属性）可以直接在页面中使用
    console.log(document)//输出一个对象，这个对象就是文档节点
    var btn = document.getElementById('btn') //通过id获取元素，其中id为‘btn’
    btn.innerHTML = '我是一个按钮' //修改按钮上的文字
快捷键：dg+回车=document.getElementById("")
       dc+回车=document.createElement("")
```

事件---交互瞬间，浏览器，点击这类的

**JS开发步骤**

1. 确定事件----document获取对象，确定对象发生的事件
2. 通常事件都会触发一个函数，其对应的函数将会被调用
3. 函数里面通常都会去操作页面元素,做一些交互动作

```html
var btn = document.getElementById('btn')
btn.onclick = function(){//onclick就是事件
    console.log('我被点啦')
    btn.innerHTML = '<font color = 'red'>我被点啦</font>';//innerHTML属性是文字，修改可以改变样式内容和样式
    btn.innerText = '<font color = 'red'>我被点啦</font>'; //改不了样式
}

script通常写在最下面，避免影响页面加载，或者在为window绑定一个onload事件，在页面加载完成后执行
<head>
    <script>
        window.onload = function(){
            var btn = document.getElementById('btn')//不然就无法识别这个btn，因为自上而下，前面没有btn
        }
    </script>
</head>
<body>
</body>
```

**DOM查询**

```html
1,id获取一个
getElementById()
2,标签名获取一组，返回一个类数组
getElementsByTagName()
3,name属性获取一组
getElemenstByName() //对于自结束标签没有意义，就是一行的标签<img/>
w
4,读取元素的属性：元素.属性名，id,value,name等，但是不可以使读取class属性，使用className
```

```html
获取元素节点的子节点
getElementsByTagName//通过具体的元素节点调用
childNodes//所有子节点，DOM标签中的空白也会当成文本节点
children//返回子元素，而不包括空白文本
fristChild//第一个子节点，也包括空白文本
fristElementChild//第一个子元素，而不包括空白文本，不支持ie8
lastChild//最后一个子节点
parentNode//只有一个

获取父节点和兄弟节点
parentNode//父节点
previousSibling//前兄弟节点，也可能获取空白文本
previousElementSibling//返回子前一个兄弟元素，而不包括空白文本
nextSibling//后兄弟节点
nextElementSibling//返回后一个兄弟节点，而不包括空白文本，不支持ie8

在事件响应函数中，事件是谁触发的，谁就是函数的this
```

```html
DOM其他查询
body查询
1，通过标签名，但是标签名是数组，所以加一个索引值
var body = document.getElementsByTagName('body')[0]
2,document中有body属性
var body = document.body
3,同样，还能获取根标签html
var html = document.documentElement;
4，获取所有，元素标签
var all = document.all
var all = document.getElementByTagName("*")

class查询
var box1 = document.getElementByClassName('box1')

根据css选择器查询
 - 只会返回唯一的元素，如果多个符合，就返回第一个
var box = querySelector('.box div')//选取box底下的div,并且只返回第一个
var box = querySelectorAll('.box div')//返回所有符合的元素，是一个数组
```

```html
dom增删改
1，创建新的元素
createElement('元素名称')//返回这个元素
2.创建新的文本
createTextNode('文本内容')
3，添加子元素
父元素.appendChild(子元素名称)
4，删除子元素
父元素.removeChild()
 - 删除元素，一般是找到这个元素，再找这个元素的父节点，常用:节点.parentNode.removeChild(节点)
5,在元素前面添加一个元素
父元素.insertBefore(要插入的元素，被插入的旧元素)

使用innerHTML可以实现一些增删改
例如：ul.innerHTML += <li>广州</li>

应用和表格插入删除配合使用，
步骤：找到需要改变的元素节点，在其分节点上操作（增加，删除子节点）
配合使用修改html
```

```html
使用DOM修改css样式
语法：元素.style.样式名 = 样式值 //加引号赋值，不然会当做变量
必须符合驼峰命名
box.style.backgroundColor = 'red' //在css中是background-color
直接设计在行内样式中，优先级大于，产生覆盖效果，若有优先级更高的，也没有效果，例如在内部样式中引用的，加上！improtant,覆盖效果是最高级的，谁也覆盖不了。
通过dom读取的css样式也是内联样式，若是没有设置是无法读取的

读取当前显示的样式 //只有ie支持
语法：元素.currentStyle.样式名 = 样式值
其他浏览器：getComputedStyle
  - 两参数：第一个是要获取样式的元素。第二个伪元素，常使用null
  - 返回一个对象，对象中封装了元素的样式
var boxStyle = getComputedStyle(box,null)
boxStyle.width//输出box的宽度
 - 优点：对于默认值，例如背景色透明，也会返回rgb，默认宽度也会返回具体长度
 - 缺点：不支持ie8及以下

兼容ie8和其他浏览器
创建一个getStyle方法
function getStyle(box,name){
return getComputedStyle(box,null)[name];//给其他浏览器使用，ie8没有这个函数
//name是变量，需要使用括号表示
return box.currentStyle.[name]//给ie使用，其他浏览器会报错，没有这个函数
}

getStyle(box,'width')

- 兼容
function getStyle(box,name){
if(getComputedStyle){//在ie8中中找不到，相当于一个变量未定义就使用
return getComputedStyle(box,null)[name];
}else{
return box.currentStyle.[name]
}
}
getStyle(box,'width')//报错，因为一个变量没有定义就使用

- 修改兼容
function getStyle(box,name){
if(window.getComputedStyle){//将变量变成一个对象的属性，一个对象里没有属性是不会报错的
return getComputedStyle(box,null)[name];
}else{
return box.currentStyle.[name]
}
}

getStyle(box,'width')//执行成功
```

```html
css中其他样式 -只读不改
- clientWidth/clientHeigth：可见宽度/高度，不带px，包括内容区和内边距
- offsetWidth/offsetHeight：获取整个元素的大小和宽度，包括内容区，内边距和边框
- offsetParent：获取离当前元素最近的开启的定位的祖先元素
- offsetTop/offsetLeft：当前元素相对于定位父元素的水平垂直偏移量
- scrollWidth/scrollHeight：滚动栏的全部高度/宽度
- scrollLeft/scrollTop：滚动栏滚动的水平，垂直距离，相当于偏移量
  - scrollHeight - scrollTop == clientHeight //证明滚动条到底了，在确定协议这类可以使用
    - 可能会出现偏差，可以四舍五入或者，取整数这类
应用：注册阅读协议，阅读获得喵币等，在滚动栏没有到底的情况下，不允许点击，不计时
获取滚动栏滚动，元素.onscroll事件
禁用按钮勾选栏等，在滚动栏没到底时，设置，disabled = 'true'
<button disabled>按钮</button>//这个按钮就不能点击
到底了就设置：disabled = 'false'
```

```html
事件对象
当事件触发响应函数时，浏览器会将一个事件对象作为一个实参传入触发函数，这个事件对象中会保存当前事件的一切信息，例如鼠标坐标，键盘按键按下，滚轮滚动
鼠标移动事件：onmousemove
滚动栏事件：onscroll
点击事件：onclick
鼠标按下：onmousedown
鼠标松开：onmouseup

 - 在ie8中不会传递一个事件对象，事件对象作为window的属性保存
     x = window.event.clientX//获取鼠标相对window的偏移量，然后将其放在该显示的div的innerHTML中
 兼容ie8：
     event = event ||window.event

DOM中获取鼠标，键盘的动作：
- clientY/clientX：返回鼠标相当于当前可见窗口的水平坐标和垂直坐标
例如，鼠标不动，拖动窗口滚动栏，坐标不变，我们看的位置也不变
但是div默认是相对整个页面的，毕竟滚动栏滚动，div位置也会改变
- pageX/pageY：相当于整个页面的鼠标偏移量，同样ie8不支持
              改良：改良盒子移动，加上滚动栏高度 
              var st = document.documentElement.scrollTop//滚动距离并不是body的，而是html的，因为html放不下body，才出现滚动栏
              var st = document.documentElement.scrollTop         
               areaDiv.style.left = x + sl +'px';
               areaDiv.style.top = y + st +'px';

事件的冒泡
事件的向上传导，当后代事件被触发时，祖先的相同事件也会被触发，比如点击事件
使用事件对象取消事件冒泡：event.cancelBubble = true

事情的委派
只绑定一次，但是可以应用到多个事件上，即使元素是后添加的
- 将元素统一绑定给共同的祖先元素，后代元素触发时，会冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件
   - 缺点，祖先元素并不只包含想绑定的子元素，例如想绑定超链接，点击祖先元素中的p也会触发事件
改良：只执行预想执行的元素，点击其他元素时，不会触发函数
事件对象的target属性：返回触发函数的对象
ul点击事件触发函数，调用event的target属性，若
event.target.className == 'alink' 就执行
```

```html
事件的绑定
普通的 元素.事件= 函数，只能同时绑定一个函数
addEventListener方法
btn.addEventListener(参数1,参数2,参数3)
 - 参数1：事件的字符串，不需要带on
 - 参数2：回调函数，当事件触发时，函数会被回调
 - 参数3：是否在捕获阶段触发事件，布尔值，一般使用false
btn.addEventListener('click',function(){1},false)
btn.addEventListener('click',function(){2},false)
btn.addEventListener('click',function(){3},false)
这个方法可以同时为同一元素同时绑定多个同样的响应函数，顺序是先绑定先执行，不支持ie8

attachEvent方法，只支持ie8
btn.attachEvent(参数1,参数2)
 - 参数1，事件的字符串，需要on
 - 参数2，回调函数
可以同时绑定多个响应函数，与addEventListener不同的是，顺序是后绑定先执行

addEventListener中的this是绑定事件的对象
attachEvent中的this是window

构造一个bind(参数1，参数2，参数3)函数，为制定对象绑定响应函数
 - 参数一：obj绑定对象
 - 参数二：eventStr需要触发的事件字符串
 - 参数三：callback回调函数

function bind(obj,eventStr,callback){
if(obj.addEventListener){
   obj.addEventListener(eventStr,callback,false)//会弹出obj
 }else{
   obj.attachEvent('on'+eventStr,callback)
   //弹出window，因为第三个参数callback在这个attach方法里调用方式就是函数，用call方法也不行
}
}
bind(btn,'click',function(){alert(this)})
改良兼容，是无论什么浏览器都是obj
修改callback的调用方式：
obj.attachEvent('on'+eventStr,function(){//匿名函数，在匿名函数里，可以修改调用方式
  //callback//相当于没有修改，
  callback.call(obj)//call是函数的方法，传入的第一个参数是对象就会成为this
})
```

```html
事件的传播
W3C将事件传播分为三部分：ie8及以下不会捕获
 - 捕获阶段：由最外层的祖先元素开始捕获，不会触发事件
 - 目标阶段：事件捕获到目标事件，触发目标事件
 - 冒泡阶段：事件从目标元素开始向祖先传递，依次触发祖先事件
如果希望在捕获阶段就触发事件，则咋addEventListener()中的第三个参数改成false
```

```html
拖拽盒子元素
当鼠标点击元素时，元素会跟着鼠标移动，鼠标松开，图标位置固定在鼠标松开的位置
box.onmousedown//绑定鼠标点击事件
var offleft = event.clientX - box.offsetLeft//确定鼠标相对盒子的水平偏移量
var offtop = event.clientY - box.offsetTop//确定鼠标相对盒子的垂直偏移量
document.onmousemove//绑定鼠标移动事件
box.style.left = (event.clientX - offleft)+'px'//鼠标坐标减去相对水平偏移，并不是像素，只是数字，加上px
box.style.top = (event.clientY - offtop)+'px'//鼠标坐标减去相对垂直偏移,盒子得开启定位，不然无法移动
document.onmouseup//绑定鼠标被取消点击事件
document.onmousemove = null //取消移动事件
document.onmouseup = null //取消抬起事件，以防不选中盒子时还执行这个函数

改良：当选择页面中所有元素时，拖拽其他元素，这个盒子也会跟着移动，
普通浏览器：加一个return false
ie8及以下：加一个捕获：setCapture()//取消捕获：releseCapture
  - 这个方法会将其他元素的事件捕获，相当于你点击了其他元素，执行的却是这个元素，类似于流氓广告，只响应一次

if(box.setCapture)//鼠标点击的时候，绑定捕获事件
{
  box.setCapture()
}
box.releseCapture()//取消点中的时候，取消捕获

改良：将这个提取出来，想拖拽就调用这个函数
function drag(obj) {
obj.onmousedown = function(event){
                 obj.setCapture && obj.setCapture()
              	 var docleft = event.clientX - obj.offsetLeft 
              	 var doctop = event.clientY - obj.offsetTop
              document.onmousemove = function(event){
              	 var left = event.clientX - docleft
              	 var top = event.clientY - doctop
              	 obj.style.left = left +'px'
              	 obj.style.top = top +'px'
              	 
              }
               document.onmouseup = function(){
               	document.onmousemove = null 
               	document.onmouseup = null
                obj.releseCapture && obj.releseCapture()
               }

              return false
             }
}
```

```html
鼠标滚轮事件
当鼠标在盒子元素上时，滚动滚轮，会改变盒子的长度
onmousewheel:ie8及以下
onwheel：普通浏览器
event.wheelDelta：获取滚轮滚动的方向，不看大小，只看正负，向上滚120，向下滚-120
```

###### js全局函数

6（编码相关）+ 2（数据处理）+ 4（数字相关）+ 1（特殊）

编码相关：

  escape()、unescape()、encodeURI()、decodeURI()、

  encodeURIComponent()、decodeURIComponent()

数据处理：

  Number()、String()

数字相关：

  isFinite()、isNaN()、parseFloat()、parseInt()

特殊：

  eval()

# json和xml



### JSON 和 XML 优缺点的比较 

#### XML优点： 

（1）格式统一，符合标准；

（2）容易与其他系统进行远程交互，数据传输比较方便。

#### XML 缺点：

 （1）XML文件庞大，文件格式复杂，传输占带宽；

（2）服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；

 （3）客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；

 （4）服务器端和客户端解析XML花费较多的资源和时间。 

 #### JSON的优点：

 （1）数据格式比较简单，易于读写，格式都是压缩的，占用带宽小； 

（2）易于解析，客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取； 

（3）支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析； 

（4）在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取； 

（5）因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。

#### JSON 缺点： 

（1） 没有XML那么通用性； XML对数据的描述性比较好

（2）JSON格式目前在Web Service中推广还属于初级阶段

# JQuery学习

花更少的代码，做更多的事

本质是js中的一个库，放置了js的方法，属性等

链式编程：方法返回对象，对象使用方法

#### js的缺点

1，原生api命名冗长难记

2，入口函数window.onload只能有一个，多个后者会覆盖前者

3，容错率低，一旦出现错误，接下来的代码都不执行

4，浏览器兼容问题

5，代码冗余

#### jq的优点

1，api命名简单

2，入口函数可以有多个

3，容错率高，一个出错，不会影响其他的

4，没有浏览器兼容问题

5，代码简洁

#### jq开发步骤

1，引入jq文件

2，写入口函数

3，根据需求找到要操作的元素（jQuery选择器），去操作它（添加属性、样式、文本）

#### jq下载

1，去jQuery官网

2，点击download，右键想下载的jq，保存到本地就是下载

3，版本区别：浏览器支持，支持低版本的浏览器，点击链接，有1-3点几的jq文件

- 1.x版本，支持老浏览器，停止更新了
- 2.x版本，不支持老浏览器，停止更新了
- 3.x版本，不支持老浏览器，依然更新中

4，版本相同中有压缩版和未压缩版

- 后缀带mim：compressed压缩过后的js文件，用于发布
- 没有mim：uncompressed没压缩的js文件，用于学习和开发

#### jq学习

```html
入口函数的写法
<script src='jquery-1.11.0.js'></script>//引入jq
		<script type="text/javascript">
            //第一种写法：$(document).ready(匿名函数)
			$(document).ready(function(){
				
			});
            //第二种写法：$(匿名函数)--常用
			$(function(){
				
			});
		</script>
```

```html
入口函数的对比
window.onload
和$(function(){})//不论先后顺序，都是jq的入口函数先执行

原因：
window.onload再页面所有信息（dom树、图片、外部链接css/js链接、）加载完才加载
$(function(){})在dom树加载完之后就加载
```

**$是什么**

1，没有引用jq文件，会报错

2，jq文件的结构：(function(){window.jQuery = window.$ = jQuery}())//自执行函数

- 引入这个js文件，是会执行这个js文件中的代码的。例如在js文件中定义了num=10，则引入这个文件页面也存在num，且值为10

3，这句话表明window.jQuery = window.$ = jQuery，$和jQuery等价，jQuery是一个函数

4，在$传递的参数不一样，效果也不一样

- 传递匿名函数--入口函数
- 传递字符串----选择器/创建一个标签
- 传递一个dom对象，把dom对象转为我jQuery对象

**dom对象**

原生js选择器产生的对象，例如document.getElementById('')

不可以调用jQuery方法或属性

**jQuery对象**

原生js选择器产生的对象，例如$('#btn')

不可以调用dom方法或属性

是一个伪数组，其实是dom对象的一个包装集

**dom对象转化为jQuery对象**

直接$(dom对象)

**jQuery对象转化为dom对象**

- 使用下标取，jq对象类似于数组，索引值为0的位置存储dom对象内容：var div = $div[0]
- 使用jQuery的方法，get()：$div.get(1)

**jq里面的方法**

```html
jq使用：$(元素).事件(function(){})----例如：$('#btn').click(function(){})

text()方法//获取和设置文本
1，获取文本
$('#box').text()//输出元素中的所有文本，包括后代
$('div').text()//获取标签名为div的所有元素的所有文本，包含多个dom元素
2，设置文本
$('#box').text('我被设置了')//也就是text方法传入的参数就是文本，文本中带有标签的也会覆盖掉

css()方法//获取和修改css样式：链式编程
1，获取css样式
$('#box').css('height')//输出盒子的高度
$('#box').css('border')//- 在ie中，不出现，获取边框只能获取一个准确的值
$('#box').css('border-top-color')//准确到哪个边框的哪个属性，且获取样式都是以rbg形式
$('div').css('height')//并不会获取所有div的样式，只有第一个
2，修改css样式，修改的是行内样式
$('#box').css('height',100)//可以不写px就不要引号，当成数值
$('#box').css('height','100px')//写了px就一定要加引号，当成字符串
$('#box').css('background-color',red)//可以使用连接命名
$('#box').css('backgroundColor',red)//也可以使用驼峰命名
$('div').css('height',100)//所有的div都会改变
3，设置多css样式
$('#div1').css({
						width:100,
						height:100,
                        backgroundColor:red,
                        'background-color':green//这个要使用引号
					})
$('div').css({
						width:100,
						height:100,
                        backgroundColor:red,
                        'background-color':green//这个要使用引号
					})//隐式迭代，所有的div也全会改变

val()---获取表单中的内容
1，val()//没有参数，就是获取
2，val('设置的值')//传入参数就时设置
```

#### jq的选择器

**基本选择器**

| 名称       | 用法           | 描述                     |
| ---------- | -------------- | ------------------------ |
| id选择器   | $('#id')       | 获取id为id的元素         |
| 类选择器   | $('.class')    | 获取类名为class的元素    |
| 标签选择器 | $('div')       | 获取所有div元素          |
| 并集选择器 | $('div,p,li')  | 获取这三个的所有元素     |
| 交集选择器 | $('dic.class') | 获取类名为class的div元素 |

**层级选择器**

| 名称       | 用法       | 描述                                                    |
| ---------- | ---------- | ------------------------------------------------------- |
| 子代选择器 | $('ul>li') | 使用大于号，获取儿子层级元素，并不会获取孙子级别的元素  |
| 后代选择器 | $('ul li') | 使用 号，获取后代层级元素，获取ul下的所有li，包括孙子等 |

**过滤选择器**

| 名称         | 用法                           | 描述                                         |
| ------------ | ------------------------------ | -------------------------------------------- |
| :eq(index)   | $('li:eq(2)').css('color',red) | 获取li元素中索引值为2的元素，索引值从0开始   |
| :odd         | $('li:odd)').css('color',red)  | 获取索引值为奇数的元素，从表现来看其实是偶数 |
| :even        | $('li:even').css('color',red)  | 获取索引值为偶数的元素                       |
| :selected    |                                | 表单中使用，过滤出选中的列表                 |
| :gt()/:lt()  |                                | 获取索引值大于/小于index的元素               |
| :frist/:last |                                | 获取第一个/最后一个元素                      |

**筛选选择器（方法）**

| 名称                 | 用法                   | 描述                                                       |
| -------------------- | ---------------------- | ---------------------------------------------------------- |
| children('子元素')   | $('ul').children('li') | 相当于子元素选择器$('ul>li')。可以不传参数                 |
| find('子元素')       | $('ul').find('li')     | 相当于后代元素选择器$('ul li')。可以不传参数               |
| siblings('兄弟节点') | $('ul').siblings('li') | 查找兄弟节点，不包括本身。可以不传参数，则全部兄弟都找     |
| parent()             | $('ul').parent()       | 查找父节点，不传参数                                       |
| eq()                 | $('ul').eq(2)          | 相当于$('li:eq(2)')                                        |
| next()               | $('ul').next()         | 查找下一个兄弟,不传参数，如果是标签，则除第一个外，都改变  |
| prev()               | $('ul').prev()         | 查找上一个兄弟，不传参数，如果是标签，除最后一个外，都改变 |

```html
鼠标移入，下拉菜单，移除菜单收回，常用this
相当于一个li标签，下面有一个a和ul>li*3,ul是隐藏的。
show()//等同于.css('display','block')
hide()//等同于.css('display','none')
不能将鼠标移入，移出的事件绑定在a上，因为a是找兄弟标签，移开a到了li中也会缩回去

mouseover移动到元素和它的子元素时都触发
mouseenter移动到元素上才触发，严谨，同理，鼠标移开，使用mouseleave

给元素设置css样式，会返回元素本身
index()//返回该元素在兄弟之间的位置

$(".frist").hover(function(){
                $(this).children("ul").slideDown();
            },function(){
                $(this).children("ul").slideUp();
            });

 $('.second>a').click(function(){
                $(this).next("ul").slideToggle()
            })
```

**jq给元素添加移除类**

```htm
1，添加：元素.addClass('css中已经定义了的类 css中已经定义了的类')//空格隔开可以添加多个
2，移除：元素.removeClass()//不带参数就是移除所有类
3，判断类：元素.hasClass()//判断一个元素有没有某个类，有则返回true，无则返回false
4，切换类：元素.toggleClass()//元素有这个类，就移除，没有就添加这个类

应用：根据导航栏，给商品区增加删除类，出现不同的商品
```

#### jq的动画

1，显示和隐藏

show()

- 没有参数就直接出现
- 第一个参数：动画出现的时间，毫秒数
  - 或者fast normal solw，分别是200，400，600，若输错，则是normai
- 第二个参数：回调函数

hide()

- 没有参数就直接出现
- 第一个参数：动画出现的时间，毫秒数
  - 或者fast normal solw，分别是200，400，600，若输错，则是normai
- 第二个参数：回调函数

2，滑入和滑出

slideDown()

- 没参数，时长是normai，400ms
- 第二个参数：回调函数

slideUp()

- 没参数，时长是normai，400ms
- 第二个参数：回调函数

slideToggle()

- 切换，和类哪个差不多

3，淡入和淡出

fadeIn()

- 没有给参数就是normal
- 同样是两参数

fadeOut()

- 没有给参数就是normal
- 同样是两参数

fadeToggle

- 切换，和类哪个差不多

fadeTo

- 淡入程度
- 第一参数，时间，
- 第二参数，透明度0-1

4，自定义动画

animate() ---四个参数，(prop,speed,easing,callback)

- 第一个参数，必填，一个对象，代表需要做动画的属性

- ```html
  $('#btn').animate({
  left:800,
  top:200,//对象
  width:200,//结束后宽度会变成200
  },)
  ```

- 第二个参数，动画执行的时长

- 第三个参数，代表速率，linear或swing，代表匀速和缓动（代表有加速)，默认是缓动

- 第四个参数，动画执行完毕后的回调函数，若在函数里作动画，就可以无缝衔接上一个动画

5，动画队列和停止动画

动画队列----在上一个动画没有完成的情况下，触发了下一个动画，导致排起了动画队列

停止动画-----stop()

- 第一个参数：boolean值，是否清除队列，就是这个动画后面的动画，要不要直接忽略。设置false则stop只对现在这个动画起作用，等动画停止后，队列的动画依次执行
- 第二个参数：boolean值，是否跳转到最终效果，若上面是true，则结果是调到这个动画的最终形态，而不是到动画队列尾巴
- 默认$(div).stop(false,false)
- 想直接执行现在的动画就在动画前加.stop(true,false)

#### jq创建节点和移除节点

1，html()

- 不带参数，获取元素中的html元素，并且返回
- 把设置的内容当做参数传入，会把原来的内容覆盖，可以解析标签

2,$()

- 可以创造元素，但是创造的元素只在内存里，需要追加一个节点
- 创造节点，append()

**添加节点**

1，append()作为最后一个子元素

- 若添加已存在的子元素，将子元素从原来的位置剪切到最后去
- 若添加别人写过的元素到父元素，也是从别人那里抢过来

2，prepend()作为第一个子元素--性质和append差不多

3，before()把元素插入到自己前面，作为兄弟

4，after()把元素插入到自己后面，作为兄弟

5，appendTo()把子元素作为父元素最后一个子元素添加到父元素中，子元素.appendTo(父元素)

**清空节点**

1，empty()清空元素，还存在，但是内容清空了

2，remove()移除元素，元素已经没了

**克隆节点**

clone()--只存在内存中，要显示，就得追加

- 有一个参数，不是必填，不论是true还是false，都会克隆后代节点
- 当是true时，克隆体也绑定本体的事件
- 当是false时，不会绑定，默认时false

**val获取表单的值**

1，原生js使用value

2，$('#btn01').val()//不传参数，获取表单的值

3，$('#btn01').val('我是这是')//传参数，设置表单的值

##### jq操作属性

1，atter---设置属性和获取属性

- 自带的属性可以设置$('#btn01').atter('src','baidu.com')
- 自定义的属性也可以设置，例如：$('#btn01').atter('aaa','aaa')//自定义的属性aaa='aaa'
- 如果没有属性，则添加这个属性
- 设置多属性$('#btn01').atter({ src:'baidu.com',aaa:'aaa'})
- 传入一个参数时，获取属性
- 自带的属性可以获取
- 自定义的属性可以获取
- 如果没有就是undefined

2，removeAtter---移除属性

- $('#btn01').removeAtter('aaa')
- 可以移除单属性，可以移除多属性

#### 内存泄露：

# Vue系统学习

### typeof的缺点：

只有‘boolean’、‘number’、’string’、‘function’‘object’的，无法区分数组

Array.isArray(arr)；

判断Array 要使用Array.isArray(arr)；
判断null请使用myVar === null；
判断某个全局变量是否存在用typeof window.myVar=== ‘undefined’；
函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。


#### Vue优点

单页面应用、轻量级、双向绑定、组件化、虚拟dom、
- 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
   - 补充：高内聚就是说相关度比较高的部分尽可能的集中，不要分散。低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖。
- 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
- 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
- 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

#### Vue实现双向绑定

用数据劫持结合发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

- 数据劫持是什么？
答案：指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。 Vue 2 使用的是 Object.defineProperty()，Vue 3改用 Proxy 进行实现

- Object.defineProperty()是什么？
有三个参数，分别是obj（要定义其上属性的对象） prop （要**定义**或修改的属性）descriptor （具体的改变方法），当调用时我们使用了它里面的get方法，当我们给这个属性赋值的时候，又用到了它里面的set方法

Object.defineProperty(obj,'hello',{
  get: function(){
    console.log('调用了get方法')
  },
  set: function(newValue){
    console.log('调用了set方法，方法的值是' + newValue);
  }//传入obj对象，定义了一个属性hello，具体改变方法包含get和set
obj.hello;//调用，则是调用get属性
obj.hello = 'hi';//赋值，则是调用set属性

- 发布-订阅者模式
Publish Subscribe Pattern，其中发布和订阅者通过第三个组件，称为代理或消息代理或事件总线，Observer和Subject都知道该组件，该组件过滤所有传入消息并相应的分发他们。

- 简单模拟双向绑定--input和p标签
<script>
    let input = document.querySelector('input')
    let p = document.querySelector('p')
    let obj = {}
    let value = ''
    Object.defineProperty(obj, 'inputvalue', {
        get() {
            return value
        },
        set(newValue) {
            input.value = newValue
            p.innerHTML = newValue
        }
    })
    // 订阅者 DOM元素
    input.value = obj.inputvalue
    p.innerHTML = obj.inputvalue
    // 监听输入的事件
    input.addEventListener('keyup', function (e) {
        // 修改inputvalue 达到修改input.value 以及input.innerHTML
        // 发布者
        obj.inputvalue = e.target.value // 触发了set
    })
</script>

#### 路由跳转

声明式（标签跳转） 编程式（ js跳转）

<router-link to="/home">首页</router-link>

this.$router.[push/replace]('/home')('/home')


模式的区别：



#### 组件传值

父组件与子组件传值
父组件通过标签上面定义传值
子组件通过props方法接受数据
子组件向父组件传递数据
子组件通过$emit方法传递参数

#### vue实现按需加载--懒加载
webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。
不进行页面按需加载引入方式：import home from '../../common/home.vue'
进行页面按需加载的引入方式：
const home = r => require.ensure( [], () => r (require('../../common/home.vue')))

const Home =()=> import('../components/Home')

#### vuex面试相关

#### vue常用周期函数

created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, el属性目前还不可见 

mounted : el被新创建的 vm.el属性目前还不可见mounted:el被新创建的vm.el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。
activated: keep-alive组件激活时调用

##### active-class是哪个组件的属性？
vue-router模块的router-link组件。

##### 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？
在router目录下的index.js文件中，对path属性加上/:id。
使用router对象的params.id。

#### 节流和防抖

防抖

触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

- 每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法
- 缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟

节流

高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

- 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return

## Vue入门语法

Vue是一个渐进式的框架，响应式？

编程范式：js是命令式编程、vue是声明式编程，数据界面分离

#### vue的下载

1，CDN引用

2，下载----学习

- 开发环境---右键另存为
- 生产环境

3， NPM安装---脚手架

#### vue基本步骤和属性

```html
<div id="app">{{message}}</div>
    <script type="text/javascript" src="../js/vue.js" ></script>
    <script>
       const app = new Vue({
        el:'#app',
        data:{
        message:'你好啊！'
        }
      })
    </script>
```

1，引入vue.js文件

2，使用new创建vue.js文件里Vue函数的实例，传入的参数为一个对象，并定义一个常量app接收它

3，vue实例中的**options**选项

- el ：用于挂载要管理的元素，例如：el:'#box'

- data:{} :对象或函数，在组件中一定是函数。用于定义数据，用于解析挂载元素使用的数据

  - 响应式--当数据发生改变时，界面自动发生改变
  - app.message = '我很好'//界面的message就改变了
  - 数据也可以是服务器请求过来的

- methods:{}:一个对象，内部属性定义方法，供给事件使用

  - ```html
    methods:{
    		add: function(){
    		console.log("add函数被调用了");
    		this.counter++;
    	//不能直接使用counter,因为会找一个全局的counter,但是counter在data对象内部，所以加this	
    					  },
    		sub: function(){
    		console.log("sub函数被调用了");
    		this.counter--;
    					   }
    		}
    ```

- computed:{}：计算属性,是一个函数，对data作一些操作

  - ```html
    应用：例如计算价格
    
    计算属性并不产生方法，里面的东西都是计算属性自己的属性
    computed:{
    //里面有一个属性fullName,它的值是一个对象,对象里有两个属性，分别是set和get
      fullName:{//可以直接使用fullName
        set:function(){
      //set方法一般不使用。可以省略掉
                      },
        get:function(){
    //get方法返回的就是属性fullName的值
                       }
                }
             }
    ```

  - ```html
    上面的简写:去掉了不常使用的set
    computed:{
      fullName:{
        get:function(){
                      }
                }
             }
    ```

  - ```html
    再简写，就成了我们常见的模式，但是本质上还是属性，这个自命名fullName的就是get属性，所以使用的时候不用调用()
    computed:{
         fullName:function(){
                      }
             }      
    ```

  - ```html
    set方法的使用：
    set(newValue){//这个参数就是get方法返回的值，被赋给了fullName，set方法会将其当做参数传入函数里
    
    }
    ```

**methods和computed的区别**

实现同一效果多次，methods使用多少次，就会调用多少次，而computed只会调用一次

#### mvvm

M:model---数据层，也就是data对象

V:view---视图层，用户页面，也就是DOM层

VM:vueModel---视图模型层，用于view和model交互

- 功能一：Data Binding，也就是数据绑定，将Model的改变实时的反应到View中
- 功能二：DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data

#### vue生命周期

生命周期函数就是vue实例在某一个时间点会自动执行的函数，可以作为options在vue实例中调用

beforeCreate(创建前)：初始化事件和生命周期相关的内容,当最基础的初始化完成的时候，el和data都是undefined
created（创建后）：注入，包括双向绑定的相关内容Init(injections & reactivity): 外部的注射，各种绑定的初始化，这部分初始化完成的时候，data存在，el不在

Has 'el' options:是否有el这个选项

Has 'template' optioins: 是否有template这个属性

　　no->Compile el's outerHtml as template: 如果实例里面没有tempalte这个属性，会把外部el挂载点的html当作模板

　　yes->Compile template into render functoin: 如果实例里面有tempalte，这个时候就会用template去渲染mounted：

beforeMount（挂载前）：有了模板之后并没有直接渲染到页面上，模板即将挂载到页面到一瞬间的时候，有el和data，但页面还没有渲染

mounted（挂载后）：mounted dom已经被渲染到页面上

beforeUpdate（更新前）：data变化时，此时data数据还没有和最新的数据同步
updated（更新后）：data变化时，此时data数据已经和最新的数据同步

beforeDestroy（销毁前）：在控制台调用vue的destroy方法：vue.$destroy()回车，销毁前
destroyed（销毁后）：销毁后，此时再改变data不会触发周期函数

<img src="D:\work\图片\331769-20180909094731362-16918169.png" style="zoom: 80%;" />

**面试考点**

Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：由外到内捕获，再由内到外渲染

- 加载渲染过程

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted（捕获终点，） -> 父 mounted

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

### vue语法

##### vue语法----插值：将值插入内容中

1，mustache---插值语法：{{}}，支持简单表达式，mastache不可以在属性中使用，只能在内容中使用

2，v-once----只使用一次，再控制台修改，不会改变

```html
<h v-once>{{message}}</h>
```

3，v-html----解析html标签

```html
<h2 v-html="url"></h2>//输出链接
```

4，v-text----如果只是单纯输出文本，和{{}}效果一样，但是如果元素存在其他文本，v-text会将效果覆盖

```html
<h2 v-text="message">，李银河！</h2> //meaasge的值时你好，最终输出也只有你好
```

5，v-pre--不进行编译，原封不动解析

```html
<h2 v-pre>{{message}}</h2>//输出{{message}}
```

6，v-cloak---在vue解析之前，自动有v-cloak，渲染出来后自动消失

```html
<h2 v-cloak>{{message}}</h2>//vue编译前有v-cloak，直到编译成功才移除v-cloak
根据这个属性解决页面加载滞后显示问题：即滞后时元素不显示
 [v-cloak]{
      	display: none;
      }
```

##### vue语法---绑定属性：v-bind

属性动态绑定的数据也储蓄在data中，属性无法识别

```html
<img src="url" />//错误，会当做字符串识别
<img v-bind:src="url" />//动态绑定：当做这个是变量，会在data中匹配，并且控制台可以响应 
<img v-bind:src="url()" />//也可以动态绑定方法
```

语法糖:

```html
普通写法：v-bind
语法糖： :
```

动态绑定class

1，对象语法

```html
<h2 class='name' :class="{类名1:boolean,类名2:boolean}">{{message}}</h2>//给元素绑定一个类对象，根据boolean值可以确定是否将类添加到元素中
boolean值存放在data中，就可动态修改
并不会覆盖原有的name class
```

2，数组语法

```html
<h2 class="titile" :class="['active', 'active2']"> {{message}}</h2>//使用数组将这三个类封装在一起赋给h2
<h2 class="titile" :class="[active, active2]"> {{message}}</h2>//数组中的是变量，动态绑定，不一定和上面一样了
```

动态绑定style

1，对象语法

```html
<h1 :style={key1(属性名):value1(属性值),key2:value2}>{{message}}</h1>
<h2 style="{background-color:red}"> {{message}}</h2>//可以使用驼峰，也可以使用连接，但是连接属性要加上引号
若不是变量，必须加引号，数值也是50px会报错，但是'50px'就不会，而且还会改变style
```

2，数组语法

```html
 <h2 :style="[basestyle,basestyle1]">{{message}}</h2>
```

##### vue语法---遍历数组：v-for

遍历数组，将数据储存在列表项名中，直接使用

```html
v-for='列表项名 in 数组'----列表项名是自定义的，
例如：<li v-for="items in movies">{{items}}</li>
```

##### vue语法---事件监听：v-on

点击、拖拽等，例如点击事件：v-on:click="getclick(index)"，常结合方法（methods）一起使用

**注意：对于点击事件**

- 如果不需要传参数，点击事件可以不写()
- 如果需要传参数

1，需要传一个参数

- 正常的getclick(123)//正常输出
- getclick()//没有输入那么函数的形参为undefined
- getclick//不报错，默认将点击事件生成的event（包含事件所有信息，例如鼠标坐标、被点击对象等）当成参数传入到方法中

2，需要传两个参数，即第一个是参数，第二个是event

- getclick(123,event)//报错，将event当做变量，没有定义这个变量
- getclick(123,$event)//第一个正常的参数，第二个是event对象
- getclick//不报错，默认第一个传入event对象，第二个为undefined  此式= geclick($event)
- getclick()//没有输入那么函数的两个形参都为undefined
- geclick(123) or geclick($event) //都默认没有输入的参数为空，undefined

语法糖

```html
普通写法：v-on
语法糖：@
```

修饰符

1，.stop---阻止冒泡

```html
@click.stop="btnClick"//给这个按钮加了阻止冒泡，点击它不会触发父元素点击事件
```

2，.prevent----阻止连坐默认事件

```html
<input type="submit" value="提交" @click.prevent="submitClick"></type>//在表单中，点击事件，同时默认提交form表单，prevent可以阻止
```

3，.enter----特定的键才触发，监听某个键帽的点击，例如回车

```html
<input type="text" @keyup.enter="keyup" />//
```

4，.once---只触发一次

```html
 <button @click.once="btn2Click">按钮2</button>
```

##### vue语法---v-if、v-else、v-if-else

条件判断

**v-if**

```html
 <h2 v-if="isshow">{{message}} </h2>//当isshow为true时，显示
```

**v-if和else**

```html
 <h2 v-if="isshow">{{message}}</h2>
<h1 v-else>isdhow为false时，显示 </h1>
```

**v-if和v-else-if和v-else**

```html
和switch用法差不多
<h2 v-if="score>=90">优秀</h2>
  <!--并不需要再要求它小于90-->
  <h2 v-else-if="score>=80">良好</h2>
  <h2 v-else-if="score>=60">合格</h2>
  <h2 v-else>不及格</h2>
```

使用条件判断修改input输入框，发现id等属性改变，但输入的内容没有切换，虚拟DOM的原因：在改变渲染时，虚拟会沿用旧的标签，还是原来的input，保留新的属性，改变旧有的属性，例如id，但是value没有更新，所以没有替换，加一个不想被复用的属性：key

```html
<input type="text" placeholder="用户账号" id="user" key="user"/>
<input type="text" placeholder="用户邮箱" id="email" key="email"/>
```

##### vue语法---v-show

也用于boolean值决定一个元素是否渲染，但是和v-if有区别

 v-show当条件是false时，是将它隐藏起来，增加了行内样式：display：none
  v-if当条件是false时，包含v-if的指令压根不会存在在dom中，是直接舍去不要的

##### vue语法----v-for循环遍历

1，遍历数组

- v-for='item in item'//遍历数组内容
- v-for='(item,index)  in item'//遍历数组内容和索引值

2，遍历对象

- v-for="items in info"//遍历对象的元素
- v-for="(items,key) in info"//获取对象元素（属性值）和key(属性名)
- v-for="(items,key,index) in info"//获取对象元素和key和索引值

key属性

数组渲染后，由于元素的复用性，虚拟DOM不会把已有的列表项标签改变，而是选择修改它的属性，调用diff函数，查看列表项和原来有什么不同，再修改。相当于把C更行位F，D更新成C，E更新成D，最后再插入E，很没有效率，相当于插入第n位，改变了N-n+2位

加key属性

```html
<li v-for="items in letters" :key="items">{{items}}</li>//使用items，确保两个item匹配
```

##### 数组中的响应式

除了修改不是响应式外，其余方法基本都是响应式

##### vue中的过滤器

也是vue中的options

```html
filters:{
   showPrice(price){
    return  '$'+price
              }
        }
使用:price | showPrice
- 分为全局和局部，上面就是局部
  // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
            Vue.filter('msgFormat', function(msg) {
                // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
                return msg.replace(/单纯/g, 'xx')
            })
- 调用过滤器的元素就是第一个参数，还可以传参数price | showPrice('罗','骆')

```

##### 函数式编程---filter、map、reduce

1、filter

参数是一个回调函数：必须返回一个boolean值，true则加入新数组中，fasle则过滤

回调函数的第一个参数是数组里的数组项

return决定是否将数组项过滤

```html
let newNums = nums.filter(function(n){
//        返回>=30的元素
           return n >= 30;
         })
```

2，map

返回数值计算

```html
let new2Nums = nums.map(function(n){
//        返回元素*2
           return n*2;
         })
```

3，reduce

对数组中所有内容进行汇总

至少传入两个参数

- 参数1：一个匿名函数，匿名函数也有两个参数，一是previousValue，二是n

  每次return的数，都会是下次遍历的previousValue，第一次是0

- 参数2：0

```html
let new3Nums = nums.reduce(function(preValue,n){
          return preValue+n;
//第一次return 0+10=10
//第二次：return 10+20=30
//第三次：return 30+30=60
        },0)
```

箭头函数：

##### vue语法---v-model

双向绑定：model绑定到view，同时view也绑定到model，即data发生改变，页面发生改变，反过来也是如此

单向绑定：model绑定到view

1，inputd双向绑定data

```html
<input type='text' v-model='message'/>
```

2，普通绑定

```html
<input type='text' :value='message' @input='valueChange'>//value绑定message，输入事件绑定message

methods:{
valueChange(){
this.message = event.target.value
}
}
<input type='text' :value='message' @input='message = $event.target.value'>

input的输入事件：input
```

**v-model结合radio使用**

1，单选框设置--表单设置

```html
<label for="">
    <input type="radio" id="male" value="男" name='sex'/>男
 </label>
 <label for="">
    <input type="radio" id="female" value="女" name='sex'/>女
 </label>
```

2，单选框---v-model

动态绑定--sex若提前设置了，单选框会被选中

```html
<label for="">
    <input type="radio" id="male" value="男" v-model="sex"/>男
  </label>
  <label for="">
    <input type="radio" id="female" value="女" v-model="sex"/>女
  </label>
```

**v-model和checkbox使用**

1，选择协议和按钮下一步绑定

按钮的disabled属性和checked取反，即选中是是ture，disabled的取值的false，可以使用

```html
<input type="checkbox" id="agree" v-model="isAgree"/>同意协议
<button :disabled="!isAgree">下一步</button>
```

2，将被选择的选项收集起来

选项框被选中时，value值会保存在hobbies数组中

```html
<input type="checkbox" value="篮球" v-model="hobbies"/>篮球
  <input type="checkbox" value="羽毛球" v-model="hobbies"/>羽毛球
  <input type="checkbox" value="排球" v-model="hobbies"/>排球
  <input type="checkbox" value="网球" v-model="hobbies"/>网球
  <input type="checkbox" value="乒乓球" v-model="hobbies"/>乒乓球

hobbies:[]
```

**v-model和select结合使用**

和上面哪个差不多，单选就是string，多选就是数组，只不过select需要绑定multiple

**input中的值绑定**

动态绑定值：input中的值不是固定的。，而是服务器决定的

1，data中设置选项数组：fruits:['苹果','香蕉','雪梨','葡萄','榴莲'],

2，根据这个数组设置checkbox：使用v-for遍历fruits，将item值也给label绑定

```html
<label v-for="item in fruits" :for="item">
//这里有input内容
</label>
```

3，再利用item给input绑定，value和item一致，id也是

```html
<input type="checkbox" :value="item" :id="item" v-model="fruitfor"/>{{item}}
```

4，这样使用item统一了for，value，id和text的内容

**v-model的修饰符的使用**

1，lazy：v-model.lazy="message"

双向绑定的响应率太高了，lazy再失去焦点或者回车时才绑定

2，number：v-model.number'="message"

v-model默认总是将赋值变成String类型，将它的属性改成number

3，trim：v-model.trim="message"

剥除，去除空格符号,过滤内容左右两边的空格

## 组件化开发

思想：开发出一个个**独立可复用**的小组件来构造我们的应用。任何的应用都会被抽象成一颗组件树。

##### 组件开发步骤

1,创建组件构造器----调用Vue.extend()

const cpn = Vue.exten()//传入一个参数，属性template

Vue.extend({

template:``//里面写html,代表我们自定义组件的模板,需要一个div包裹。

})

2,注册组件---调用Vue.component()

- 第一个参数是给它起一个组件的标签名称。
- 第一个参数是构造的组件

Vue.component('my-cpn',cpn)

3,使用组件

类似于将它封装位一个标签，直接再vue挂载过的元素中使用

<my-cpn></my-cpn>

##### 全局组件和局部组件

1，全局组件：调用Vue.component()注册组件不是在一个实例中创建，而是全局script的，可以在多个Vue实例中使用

2，局部组件：在一个实例中创建组件，使用options中的components

```html
components:{
 cpn:cpn//左边是命名，右边是注册了的组件
}
```

##### 子组件和父组件

root根组件：Vue实例，是父组件的父组件

1，创建子组件

```html
var cpnson = Vue.extend({

template:``//子组件内容

})
```

2，创建父组件，将子组件注册在父组件，并且使用子组件

```html
var cpnparent = Vue.extend({
template:`
<cpnSon></cpnSon>//3，使用子组件
`,//1,父组件模板
components:{
cpnSon:cpnson//2,注册子组件
}
})
```

3，在vue实例中注册父组件

```html
components:{
cpnParent:cpnpaerent//2,注册子组件
}
```

4，子组件只在父组件中注册，所以单独的子组件便签是不能使用的，除非在其他实例中注册了

##### 组件的语法糖

1，全局组件

- 省略extend，在全局里，将组件构造器和注册放在一起，直接传入一个对象，内部还是会调用extend

  ```html
  Vue.component('cpn',{
          template:`
          <div>
          <h2>我是标题</h2>
          <p>我是内容</p>
          <p>我是内容啦啦啦</p>
          </div>
          `
        })
  ```

2，局部组件

- 直接在options中的component中使用

  ```html
  components:{
     cpn: {
  template:`<h2>我是标题1</h2>`   
          },
     cpn1: {
  template:`<h2>我是标题2</h2>`   
          }
  }
  ```

##### 模板分类写法

1，script标签

type需要修改：type='text/x-template'

需要定义一个id，在注册组件的时候接收它

2，template标签

同样定义一个id

##### 组件的数据

1，组件不能使用实例的数据，需要在创建的时候自己创建data数据属性

2，组件的可以有data和methods，都写在自己的属性中，但是data必须是函数

3，data为什么一定是函数，而且返回一个对象，在返回的对象中进行数据定义

- 在页面上复用组件，相当于在调用data，

- 若data是一个对象，则每次使用都在调用一个对象，返回的地址都是一样的，即每次调用，改变一个组件，data会跟着改变，从而改变了其他组件

  ```html
  1,data使用的是对象
  
  obj= {
      num:1 //创建一个对象
         }
  data(){
  return obj //返回一个对象
  }
  <cpn></cpn>//使用组件，我改变了num,等价于 obj.num = 0=0
  <cpn></cpn>//num = 0
  <cpn></cpn>//num = 0
  
  ```

```html
2，data是一个函数，函数返回一个对象，不一样的对象地址,但是对象看起来都是一样的

Vue.component('cpn',{
        template:'#cpn',
        data(){//每次使用data都是在调用data
          return{
            counter:0
          }
        },
          methods:{
            increment(){
              this.counter++
            },
            decrement(){
              this.counter-- 
            },
          }
      })
```

##### 父子组件通信

vue语法，监听，绑定等都可以在子组件中使用

![](D:\work\图片\图片1.png)

1，父组件到子组件---props

- 在子组件添加props属性，可以放置数组、和对象

  ```html
  1，props:['cmovies','cmessage']//数组
  
  2，props:{//对象
            cmessage:{
              type:String,
              default:'aaaa',
              required:true
            },
            cmovies:{
              default:['暮光之城']
            }
          }
  ```

- props中定义的变量可以在组件中使用，组件绑定父组件的data属性

  ```html
  <cpn :cmovies='movies' :cmovies="message"></cpn>
  ```

- 在子组件中使用cmovies和cmovies，就是在使用父组件的mocies和message

```html
<h1>{{cmovies}}</h1>
  <h2>{{cmessage}}</h2>
```

- 使用props创建对象

1.1，type--类型限制：String、Number、Boolean、Array、Object、Date、Function、Symbol

1.2，default---提供默认值，当没有传变量是就显示：

1.3，required---boolean值，表示必传值，当是true时，必须传一个变量，否则报错

1.4，当vue版本过低时，类型是数组或数组时，默认值必须时一个对象

1.5，驼峰问题：html会自动将标签转化为小写，所以不支持驼峰写法：例如通过props创建cMes变量，还是要定义为cmes,或者在html中使用c-mes，不需要引号包裹

父组件使用子组件也不能使用驼峰

```html
cmessage:{
            type:String,//类型
            default:'aaaa',//默认值
            required:true//必传
          }

1，当类型是数组和对象时
cmessage:{
         type:Array,//对象时数组
         default(){//传入一个对象
         return []
         }
```

2，子组件传到父组件---$emit event(发射事件)

2.1，子组件发生事件，监听事件，在事件触发的方法中发射一个自定义事件btnclick

```html
 @click="itemClick(item)"//子组件发生点击事件
methods:{//子组件的方法
       itemClick(item){
            this.$emit('btnclick',item)
                }
         }
```

2.2，父组件监听这个事件，然后在自己的methods中使用cpnClick处理事件

不需要参数，这不是浏览器产生的事件，在父组件中不存在，所以默认会将子组件的参数传过来，反而传参数会报错，因为没有定义

```html
<div id="app">
  <cpn @btnclick="cpnClick"></cpn>
</div>

```

##### 父子组件双向绑定---Vue10-model

父组件：num

props：number绑定num

data：dnumber:number

错误想法：在父组件向子组件元素传递信息，可以通过父组件修改子组件的元素number，在子组件的input中使用v-model双向绑定props中的元素，达到自己修改自己number的内容,不影响父组件

```html
<input type="text"  v-model='number1'/><br /> 
```

因为浏览器要求避免props，展示可以直接使用props但是要修改就一定要放置在data

在子组件加一个data属性，将props的的值赋值给data（不要忘记this），并且使用v-model在input中双向绑定data中的属性

```html
data(){
              return{
//data放置初始number值,绑定后,就舍弃number只修改data和input
                dnumber1:this.number1,
                dnumber2:this.number2
              }
            }
```

子组件的一个输入框，实现在子组件输入，修改父组件的变量，由于没有绑定props，所以不止父组件没有改变，连子组件都没改变，输入事件触发发射事件，此时发射事件的参数得是data里面的

1，将v-model拆分为，绑定和监听，绑定value，监听输入事件，根据输入事件改变dnumber从而改变value

```html
<input type="text"  :value='dnumber1' @input="dnumber1 = $event.target.value"/>

<input type="text"  :value='dnumber1' @input="num1Input"/>//绑定方法，自动传入事件为参数
```

2，在输入事件触发的num1Input方法中顺便发射事件，以便让父组件接受事件，并且传入dnumber做为参数

```html
num1Input(event){
//              1,将input的value赋值到dnumber中
                this.dnumber1 = event.target.value;
//             2，为了让父组件修改值,发射一个事件
                this.$emit('num1change', this.dnumber1);
                }
```

3，父组件接受事件，并监听，触发修改方法

```htm
<cpn :number1="num1" :number2="num2" @num1change='num1change1'  @num2change='num2change2'></cpn>

 num1change1(value){
            this.num1 = parseFloat(value)
          },
```

<img src="E:\BaiduNetdiskDownload\VUE笔记\Day 04\上课画图\01-组件通信案例的画图分析.png" style="zoom: 200%;" />

**组件中watch--监听属性改变**

num(newValue,oldValue){//旧值和新改变的值

this.num1 = newValue//实现绑定另外一个值

//不用来改变自己，因为还是会触发这个方法的吧

}

##### 父子组件相互访问

父组件访问子组件

1，$children：结果是一个数组，子组件的个数就是数组的长度

2，$refs：由于索引值的变动，不能准确的访问某一个子组件。结果默认为空，当给子组件加ref='aaa'时，这个aaa就当做对象的属性，可以根据这个属性访问到子组件

子组件访问父组件

1，$parent

##### 插槽slot的使用

1，为了组件的拓展性，抽取共性，保留不同

2，插槽的使用：在子组件中加入插槽标签

 2.1 插槽元素内填写默认内容

 2.1 组件中插入内容则覆盖默认插槽

3，具名插槽：当子组件不一定只使用一个插槽，而是多个，在插槽中加入name属性做区分

## 前端模块化

### 模块化开发

#### 代码复用性：

在一个js中定义过的全局变量name，根据js加载顺序，在这个js后的其他js文件中可以直接使用，但是同时其他js文件也可以定义这个全局变量name，不会冲突。

**缺点：**我想用之前自己定义过的变量，结果别人定义了我也可以使用，导致真正想使用的变量被覆盖

**解决思路：**将开发分为不同模块，每个模块不会影响，需要使用时单独调用一个模块

1，匿名函数闭包：使用函数作用域的思想，提高复用性--可以定义一个空对象，将需导出的变量放入到对象中，并且return obj，接收这个对象，需要使用就调用这个对象里的属性

2，CommonJs实现导入导出---webpack中使用，但是ES6不支持，不能直接使用

在a.js文件底下导出：

```
module.exports = {//固定写法
     //1，普通写法
  	  flag:flag,
  	  num:num
  	//2，对象字面量增强写法
  	  flag，num
 	//3，直接赋值
  	  flag:true，
  	  num:5
	}
```

  在另一个b.js文件导入：

```
var { falg,num } = require('./a.js')
  解构，等同于将aaa对象解析出来：
	var aaa = require('./a.js')
	var falg= aaa.falg
	var falg = aaa.num
```

3，ES6实现导入和导出

  1，将需引入、引出的js文件的type改成module

```
<script src='./a.js' type='module'></script>
```

  2，导出单个变量/函数/类

```
export let name = 'haha'//定义时就可导出
```

  3，导出多个变量/函数/类

```
export {flag,num}//在js文件底下导出
```

  4，导入，可以同时接受单个导出和多个导出（需导入的js文件添加type='module'）

```
 import {flag,num,name} from "./aaa.js" //js后缀名不可省，即使只有一个变量{}也不可省，名字是由导出决定的，而且路径不能省，需要加上./
```

**补充：**ES6中的类----特殊的函数

```
class Person{//一个类
  run() {}//类中的方法
}
```

 - 类不能未声明就使用
 - 同一个类不能重复声明
 - 类必须使用new实例化
 - 可以使用匿名类
 - 可以直接使用类中的方法run

## webpack

模块打包工具， 支持模块化，处理模块化的依赖，将js，css，less，html文件打包，

webpack 依赖于 nodejs，node环境包含很多依赖的包，
npm（node packages manager）
依赖关系如下：webpack -- node -- 包 -- npm

### 安装webpack

- 首先在cmd中全局安装webpack：
npm install -g webpack@3.6.0(脚手架2依赖该版本)
 - 其次每开发一个webpack**项目**都要局部安装一个webpack：
npm install webpack@3.6.0 --save-dev
会在项目中生成一个node_modules文件夹
 - 项目安装淘宝镜像使用cnpm代替npm：
npm install -g cnpm --registry=https://registry.npm.taobao.org
卸载：npm uninstall cnpm -g
 - 终端使用npm命令：
Terminal：cd是进入下一层 cd .. 是回到上一层目录
终止批处理：ctrl+c

### 初始化webpack文件目录

![](D:\work\图片\webpack初框架.png)

第一级主要分为：src、dist、index.html、webpack.config.js、package.json、node_modules
 - 2.1、src文件结构，开发时所有代码，包括：
1，js文件夹：放置js文件
2，main.js文件：唯一，打包入口，依赖于所有其他文件
3，vue文件夹：互相依赖，最终导入main.js的只有App.vue
4，css文件夹：编写css文件
 - 2.2、index.html文件：唯一，且只引入**bundle.js**和app.vue
```
<div id="app">
</div> 即App的vue挂载
```

 - 2.3、dist文件夹，所有文件都将打包在其之下，最后发布则是用这个文件夹
   
- 打包出两个文件：bundle.js(包括src里的js、css、vue)和index.html（基于index.html）
  
- 3，package.json
  当程序需要依赖node中的包时，需要**配置**package.json

  ```
  语法：cmd中输入npm init
  ```

  package name：取名字：尽量不使用中文：meet
  entry point 是入口：取名index.js
  最后一系列配置下来，就可以生成一个配置文件package.json


- 4，vscode无法使用脚本指令
  因为webstrom太慢了，推荐使用vscode
- 4.1以管理员身份运行vscode
  
- 4.2set-ExecutionPolicy RemoteSigned
  
- 4.4出现错误，输入报错信息的提示
  
- 4.5设置为RemoteSigned

### webpack打包

![](D:\work\图片\最终打包配方.png)

#### 1，将所有js文件打包

原理:将main文件打包到dist文件下的bundle.js文件中,不需要其他文件，因为main会自动引入它所依赖的文件（可以直接使用CommonJs和import和export导入导出）

**法1：**直接使用webpack打包--将需要打包的文件打包到文件里

```ht
终端语法：webpack  ./src/main.js  ./dist/bundle.js //注：每次修改js后都要重新打包
```

**法2：**映射入口文件和出口文件，使用webpack就可以完成
步骤1，创建webpack.config.js配置文件（与dist同级，固定的）
步骤2，在webpack.config.js配置文件配置入口和出口：

```
module.exports ={
	entry:入口，直接是'./src/main.js'
	output:出口，对象类型{}，包含两个属性{path:,filename:}
	}
```

 - 1.路径 path，需使用绝对路径，不可以直接使用'./dist'。
     - 1.1动态获取绝对路径
	- const path = require('path')// 引入node内置全局的路径包，需要配置package.json

	- 在path调用path.resolve函数，将两个路径拼接在一起：
	- path:path.resolve( __dirname,'dist')//双下划线dirname是node自带的全局变量，从根路径开始，保存到当前所在的路径，是动态的。
 - 2.文件名字filename
      直接取名filename:‘bundle.js’
      步骤3，在控制台输入webpack就会自动打包

**法3：**映射自定义命令，简化指令。基于法2的配置，用npm run build映射webpack

- 1，打开dist同层文件package.json文件
  修改"scripts"属性，此属性名为脚本，当控制台执行npm run xxx时，会先去"scripts"中找xxx，即执行xxx所指代的命令

- 2，加入,"build"："webpack"//即执行webpack，**执行必须使用双引号**

- 优点：在终端的命令都是全局的，但是**配置脚本**后优先找到本地的webpack，因为项目使用的webpack和本地的不一定相同

- 3，在开发项目前，也该配置一个本地webpack

  ```
  终端语法：npm install webpack@版本 --save-dev
  ```

- 会在package.json中生成属性

  ```
  "devDependencies":{"webpack":"^3.6.0"}//开发时依赖的webpack版本
  "depensencies":{}//它下面还有一个运行时依赖
  ```

- 同时在dist同层目录下生成一个包含很多包的文件夹：node_modules

#### 2，将所有css文件打包


- 也将css文件依赖到main.js文件中，即与bundle对接的始终只有main.js文件，main作为所有文件的入口。

	```
	代码语法：require("./css/style.css")//在main.js中输入
	```
	
- loader：webpack只负责处理js，需要loader帮助加载处理css和图片等文件，安装两个loader，一是加载css文件，一是编译css文件
  语法：1，通过npm安装需要使用的loader。2，在webpack.config.js文件中配置module属性，即loader
  步骤1，安装：输入：npm install --save-dev css-loader@2.0.2
  步骤2，配置：进入到**webpack.config.js**文件夹中的导出中加入

  ```
  1，npm install --save-dev css-loader@2.0.2
  
  2，配置loader
  module.exports={//导出
                //前面是打包入口和出口
  module:{
  rules：[//配置使用规则
  {
           test:/\.css$/, //正则表达式：$表示结尾。匹配css文件
           use:['style-loader','css-loader'] //将上面匹配的css文件拿来做应用
  }
              ]
  	}
                 }
  ```

- 在导出的module.exports对象中，加一个module属性，里面配置rules规则属性，rules的值是一个数组，数组包含多个对象，每一个对象对应一个loader规则，有test和use两个属性
其中css-loader只负责加载css文件
style-loader将样式添加到DOM里面，所以有第三步
步骤3，加载style-loader：输入：npm install --save-dev style-loader@0.23.1
注释：多个loader的加载规则是从右到左，所以'style-loader','css-loader'

#### 3，将less文件转为css文件

也是直接在main文件中依赖，配置lodaer可以直接去webpackjs.com找
1、安装加载将less文件转化为css文件的less.loader
语法：npm install --save-dev less-loader@4.1.0 less@3.9.0


- 下载了两个东西。loader是加载less文件，less是一个包，可以编译less文件变成css文件，所以也需下载
  2、配置webpack.config.js文件,在mould.exports中rule加入规则

  ```
  module.exports={
  //这里放置打包入口和出口
   rules:[//rules数组放置对象，每一个对象打包一类文件
            	   {//css规则},
                   {
     test: /\.less$/,
        	      use: [//less文件的ues是对象，为了添加其他可能使用上的属性，如只有loader一个属性，可以直接使用普通字符串
          	         { loader: 'style-loader' },
          	         { loader: 'css-loader'｝,
         ｛ loader：'  less-loader'｝
                              ]
                      }
           ]
  	          }
  ```

#### 4、webpack图片处理loader

- 1，下载url-loader
    npm install url-loader@1.1.2 --save-dev
    2,配置
    同样是配置在webpack.config.js，和上面两个不同，

  ```
    module.exports = {
    //这里放置打包入口和出口
     rules:[//rules数组放置对象，每一个对象打包一类文件
             	   {//css规则},
                    {
       test: /\.(jpg|png)$/,
         	      use: [
           	         { loader: 'url-loader' ,
                            options:{
    	limit:8192,
    	name:'img/[name].[hash:8].[ext]'
                                        }
                          },
                               ]
                       }
             ]	          
               }
  ```

- 1，test改成或形态  |jpg|png

- 2，use的配置是对象，不单有loader，还有options:{
	limit:8192//表示图片的大小不超过8kb：8×1024
                                   }
	1）若图片小于8kb，则会将图片编译成base64字符串
	2）若图片大于，则报错，需要再配置file.loader
	3,配置file.loader
	语法：npm install --save-dev file-loader@3.0.1
	
- 使用后会将‘大于的图片’打包放在dist文件夹下，并且使用哈希表重新编译文件名，防止命名重复。

- 而页面自动响应的是直接图片文件名，并不是同一级，缺少./dist，需要重新引用这个文件。
  找到在webpack.config.js文件
  在output（输出）下，加上：
  PublicPath:'./dist'    //配置url路径，一旦加载url文件，就会从这个文件下找（后期html文件在dist下，需要删去这个）
  4，修改图片名称

- 原因：哈希命名有32位，而且需要将图片都打包在dist下的img文件夹下，这样可能本来在不同路径但同名的图片现在出现dist的文件下冲突。

- 步骤：找到webpack.config.js文件下，配置图片的loader
  在use中的options里添加一个name属性：
  语法：name:'img/[name].[hash:8].[ext]'
  在img文件下，需要加[]表示变量，否则当成常量，哈希值也是变量，哈希截取八位，ext表示文件后缀

#### 5，webpack将ES6文件转化为ES5

- 原因：bundle.js只会保存ES6,需要转化为ES5兼容

- 使用babel对应的loader，
	1,下载，babel-core编译ES6，babel-preset-es2015就是ES5
	npm install --save-dev babel-loader@7 balel-core babel-preset-es2015
	2,配置webpack.config.js
	在module下的rules中加入转化ES6的规则

	```
	module.exports = {
  //这里放置打包入口和出口
   rules:[//rules数组放置对象，每一个对象打包一类文件
            	   {//css规则},
                   {//less规则},
	                 {//图片规则},
	                 {
     test: /\.js$/,
    exclude: /(node_modules|bowew_components)/
        	      use: {
                              loader:'babel-loader',
                              options:{
                                   presets:['es2015']
                                           }
	                            }
	                  }
	         ]
	            }
	```
	
- exclude只转化src文件夹下的js文件，将安装的局部webpack取消转化ES5

### webpack配置Vue

1，引入vue
- 以前是下载引用vue.js

- 现在是npm安装vue

```
语法：npm install vue@2.5.21 --save
```

- 依然要在main.js中依赖vue

```
语法：import Vue form "vue"
```

- 但是在html上使用实例时会错误，原因：
1，runtime-only---不允许有template
2,runtime-compiler---允许有template，即使没有templat，html中的也是template
默认情况下使用的vue版本配置only，手动配置runtime-compiler版的vue
在webpack.config.js中，与第一级里，加入resolve属性:

```
resolve:{
  alias:{
	     'vue$':'vue/dist/vue.esm.js'//匹配node_modules下的vue-dist-vue.esm.js
	          }
	}
```

2，Vue的结构
SPA(simple page web application)//单页面应用
- 1，将所有结构组件化
  html文件不修改，必须将要修改的东西抽取出来，template会替换我们的el
  组件化开发，将单个组件写在单个js文件，在main.js中引入，然后注册组件，在template直接使用

 - 1.1，组件js文件：一个组件一个文件，直接默认导出一个对象，包括template，data()函数return一个数据对象等
	
	```
	export default {//这个文件放在src下的vue文件夹中
	  template:`
	    <div>
	      <h2>{{message}}</h2>
	    </div>`,
	  data(){
	    return{
	      message: 'hello!'
	               }
	           }
	}
	```
	
 - 1.2，在main.js中导入组件js文件，自命名App

  ```
  语法：import App from './vue/app.js'//不使用require
  ```

 - 1.3，在main.js的vue实例中注册组件App
   
	```
	import Vue form "vue"//先引入vue
	new Vue({
	el:'#app',
	template:'<App/>',//这里就写标签的模式
	components:{
	App
	}
	})
	```
	
 - 1.4，在main.js中的template中直接使用


- 2，使用.vue文件进行组件分离
  传统的js文件写组件将template和data放在一起，而vue文件将template和script分开

 - 2.1 vue文件初始化
	在src-vue下创建vue文件
	初始文件模样：
	
	```html
	<template>
	</template>
	<script>
	export default {
	name:'App'}
	</script>
	```
<style>
	</style>
	```
	
	将js文件中的template放入，将data和methods放入script
	
	```html
	<template>
	    <div>
	      <h2>{{message}}</h2>
	    </div>
	</template>
	<script>
	   export default {
	        name:'App',
	          data(){
	              return{
	                 message: 'hello!'
	                         }
	                   }
	                   }
	</script>
	<style>
	</style>
	```

- 2.2，webpack不能识别vue文件，需配置对应的loader

```
语法：npm install --save-dev vue-loader@13.0.0 vue-template-compiler@2.5.21(组件编译)
```

- 在webpack.config.js中配置规则

```
webpack.config.js--module.export = --module---rules--{}
语法：
	{
	test:/\.vue$/,
	use:['vue-loader']
	}
```

- 在main中引入组件

  ```
  import App from './vue/app.vue' //在js文件中可省文件后缀名，在vue中不可省
  ```

- 如想省去后缀名，则在resolve中加入extensions属性

  ```
  webpack.config.js--module.exports= --resolve
  语法：extensions:['.js','.vue','.css']
  ```

 - 2.3，vue-loader版本需要安装13.x.x的
    loader安装版本过高，需配置插件或重新安装低版本loader
    1，安装低版本loader

 - 修改package.json的运行时配置里找到vue-loader
    修改为'vue-loader':'^13'
    或'vue-loader':'~13.0.0'

 - 在运行端重新下载：npm install
2，安装plugin插件

### webpack使用plugin插件

对webpack进行扩展，如打包优化，文件压缩等
- loader和plugin区别
loader主要用于转换某些类型的模块，它是一个转换器。
plugin是插件，它是对webpack本身的扩展，是一个扩展器。

 - 1，在打包文件头添加版权注释
这是webpack自带的插件。
直接在webpack.config.js中导入webpack

```
语法：const webpack = require('webpack')
```

 - 在导出配置版权

```
语法：module.exports = {
//这里是入出口、module、resolve
plugins:[
	new webpack.BannerPlugin('最终版权归我所有')
	]
	}
```

- 2，打包html的plugin
在dist文件下自动生成html文件，和bundle.js同级，而且自动引入bundle.js文件
并不是webpack自带的插件，需安装HtmlWebpackPlugin插件

```
语法：npm install html-webpack-plugin@3.2.0 --save-dev
```

- 导入HtmlWebpackPlugin插件
进入webpack.config.js文件

```
const HtmlWebpackPlugin = require('html-webpack-plugin')
```

- 在plugin中使用

```
语法：module.exports = {
//这里是入出口、module、resolve
plugins:[
new webpack.BannerPlugin('最终版权归我所有'),
new HtmlWebpackPlugin()
]
	}
```

- 此时，重新打包后，dist文件下自动生成index.html文件

```html
<html>

<head>
</head>

<body>
	
	  <script type='text/javascript' src='dist/bundle.js'></script>
	
	</body>
	</html>
```

- 产生两个问题:

- 文件自动配置的publicPath导致script多了一个dist
  解决：找到webpack.config.js删除publicPath

- 还有，少了vue挂载<div id='app'> </div>或者其他本来html有的东西
	在new插件的时候传入模板，则自动在同级匹配html文件

	```
	语法：module.exports = {
	//这里是入出口、module、resolve
	plugins:[
	new webpack.BannerPlugin('最终版权归我所有'),
	new HtmlWebpackPlugin({
	template:'index.html'
		})
	            ]
	}
	```
	
 - 3，使用plugin压缩js文件
对bundle.js文件进行丑化，删除空格，注释、命名压缩等
安装uglifyjs-webpack-plugin插件

```
语法：npm install uglifyjs-webpack-plugin@1.1.1 --save-dev
```

 - 进入webpack.config.js文件引入UglifyjsWebpackPlugin插件
进入webpack.config.js文件

```
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
语法：module.exports = {
//这里是入出口、module、resolve
plugins:[
	new webpack.BannerPlugin('最终版权归我所有'),
	new UglifyjsWebpackPlugin()//实际上上面会被丑化删除
	]
	}
```

### webpack搭建本地服务器

因为更新js、css、vue文件时，需要重新使用打包文件才能更新，降低开发效率。需要搭建一个基于基于node.js的本地服务器，监听代码是否改变并实时编译，在内存中更新用于测试，没有映射到硬盘（也就是bundle.js没有改变），最终只打包一次，就可以发布
 -1，安装本地服务器
语法：npm install --save-dev webpack-dev-server@2.9.3

 - 2,修改配置
	在webpack.config.js第一级下配置devServer属性
	devServer:{
	  contentBase:'./dist',//指定为哪一个文件夹提供本地服务，默认是根文件夹，填写./dist
	  port:,//端口，也就是页面端口

 	  inline:true,//页面实时刷新
 	  historyApiFallback：//在SPA页面中，依赖HTML5的history模式
 	}
 - 先配置contentBase和inline就可以实现
 - 3，运行
终端的命令是全局的，但是服务器是本地的，需要配置脚本
package.json中"script"加入
"dev":"webpack-dev-server"
终端使用：npm run dev
这样每次修改，不用执行命令，直接保存在页面上刷新就可以实现修改
启动本地服务器时自动打开页面
"dev":"webpack-dev-server --open"

### 配置文件webpack.congfig的分离

- 压缩丑化是打包发布时需要的配置，而本地服务器是开发时需要的配置，建议分离成开发时的配置文件和运行时需要的配置文件
将webpack.config.js抽离为三个文件：
base.config.js（基础）和dev.config.js（开发）和prod.config.js（生产）
 - 1，先在webpack的分离配置下创建一个build文件夹和三个基本js文件
 - -dev.config.js保留运行时的配置，也就是devServer
	语法：module.exports ={
	devServer:{
	contentBase:'./dist',
                inline:true
	                }
	}
- -base.config.js保留基础配置
- -prod.config.js保留发布时需要的配置，也就是丑化
	const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
	modulre.exports = {
	plugins:[
	new UglifyjsWebpackPlugin(),
	         ]
	}
- -base.config.js保留基础配置
base文件除了原来的，删去丑化和本地服务器，当开发时使用base+dev，发布时使用base+prod
- 2，安装merge
要将文件合并，必须安装merge来将base文件与它们拼接起来
语法：npm install --save-dev webpack-merge@4.1.5
 - 3，在prod.js和dev.js中配置merge
   - prod中：先导入merge，再导入base文件，最后调用merge中的函数合并两个文件
   const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
   const webpackMerge =require('webpack-merge')//第一步
   const baseConfig = require('./base.config')//第二步
   module.exports = webpackMerge(baseConfig,{//第三步
	plugins:[
	new UglifyjsWebpackPlugin(),
	         ]
   })
 - dev中：先导入merge，再导入base文件，最后调用merge中的函数合并两个文件
const webpackMerge =require('webpack-merge')//第一步
const baseConfig = require('./base.config')//第二步
module.exports = webpackMerge(baseConfig,{//第三步
	devServer:{
	contentBase:'./dist',
                inline:true
	                }
})
 - 4，配置新文件
此时已经使用build下三个配置文件代替了webpack.config.js文件，但是系统默认将命名为webpack.congig.js作为打包配置文件，无法识别build
解决:在package.json中修改webpack的匹配
"build": "webpack --config ./build/prod.config.js"
和dev的匹配
"dev": "webpack-dev-server --open --config ./build/dev.config.js"
 - 5，修改打包路径
当使用prod/dev进行打包时，由于base中指定的output路径是当前路径，而当前路径再build下，所有打包会再build下生成dist文件夹
解决：返回上一路径
path.resolve(__dirname, '../dist'),

## 脚手架

### 安装脚手架

在开发时不会手动配置webpack，而是使用脚手架Vue CLI自动配置webpack CLI（命令行界面） 安装脚手架前准备：node.js和webpack 直接使用npm安装，也就是依赖于node.js 需要配置webpack，也就是需要webpack全局安装

- 1，安装Vue脚手架，全局安装 cmd中输入npm install -g @vue/cli@3.2.1 
- 2，vue --version 查看安装脚手架的版本
- 3，如果安装了脚手架3，会覆盖脚手架2，如果仍让需要使用脚手架2，需要安装拉取脚手架2的模板 npm install @vue/cli-init -g

### 使用脚手架架2和3

- Vue CLI2初始化项目
  语法：vue init webpack 项目名称
  Project name  敲回车表示和项目名称保持一致，不能包含大写
  Project description 项目描述，默认从git获取，会保存在package.js
  Auther 作者，可修改
  Vue build 构建方式，选择Runtime-only
  install vue-router 安装路由
  Use ESlint to lint your code 语法规范，一般选择n
  有两种：Standard/Airbnb
  set up unit tests 单元测试，选择n
  setup e2e（end to end）tests with Nightwatch 端到端测试，选择n
  should we run 选择 npm
- Vue CLI3初始化项目
  语法：vue create 项目名称
  在选择only和comter时，选择下面那个，将加载插件的步骤省略了

### 脚手架文件目录结构

去package.json文件中读懂cli2自动生成的文件目录结构

- 配置文件
 - build文件夹
      - 当执行npm run build时，其实是执行node build/build.js
      - node为js文件创建了一个执行环境，不需要html和浏览器就能直接编译js，使用本身的v8引擎编译
     例如 node test.js//直接执行test文件
      - 逻辑--node执行build.js--build导入webpack.prod.conf--执行rm(removie)，当执行npm run build时，先将原来打包的文件夹删除--再通过webpack执行webpack.prod.conf---来到webpack.prod.conf--导入了webpack.base.conf也就是基础配置--使用merge合并两个文件
     - 当执行npm run dev时，其实是执行webpack-dev-server --inline --progress --config build/webpack.dev.conf.js概念和上面差不多
 - config文件夹
    - index.js主要的变量配置，可以修改端口号、是否自动打开浏览器等
    - dev.env.js 开发时的变量配置
    - prod.env.js 生产时候的配置
- node_module文件夹
- src文件夹
- static文件夹
静态资源，原封不动的放入dist文件夹
- babelrc文件
将语法转化为ES5，还有一些浏览器的匹配
editorconfig
对代码做一个统一规范
package-lock
因为package.json安装的版本可以有区间
例如^是指定2.6.20前两个数字2.xx
而~是指定2.6.20前一个数字2.xx



# 微信小程序开发

## 小程序开发语法

#### 1，开发准备；

- 注册账号：一个邮箱一个（appID），下载微信开发工具，创建小程序项目

- 使用vscode为主要开发工具，先配置插件：minapp、wxapp-helper-xwml、小程序开发助手

#### 2，小程序原本框架

- app.json--全局配置文件

page：设置小程序页面，增添页面可通过这里，也可同过编辑

window：配置导航栏

tabbar：配置选项卡

- app.js---全局逻辑文件
- app.wxss---全局样式文件
- pages---存放页面的文件夹
- utils---存放公共js的文件夹

#### 3，小程序页面

小程序时单页面富应用开发模式，虽然有很多页面，但是页面都在同一个根下跳转

1，小程序的页面通过全局配置的page创建

语法："pages/login/login"//最后这个login指的是login.html

2，自动在pages下生成一个login文件夹，里面包括四个文件

login.wxss

4，页面配置----index.json

navigator

微信小程序语法：

text标签：等同于span标签

view标签：等同于div标签

5，js文件的page函数----等同于vue实例

1，data数据以及使用

- {{}}---插值语法

- wx:for----列表渲染：等同于v-for

  wx:for='{{数组}}'

  wx:for-item='循环项名称'---默认为item，对象最好写成value

  wx:for-index='循环项索引'---默认为index，对象为属性名，最好写成key

  wx:key='唯一的值'---提高列表的渲染能力

  -1，可以是唯一的属性，例如：wx:for='id'

  -2，*this当数组时，表示循环项本身

- block标签：占位符，页面渲染时被移除

  boolean值也需要用插值{{}}，例如:wx:if='{{true}}'

- wx:if----条件渲染：等同于v-if

  wx:if='{{true/false}}'----if

  wx:elif='{{true/false}}'----else if

  wx:else='{{true/false}}'---else

- hidden----等同于v-show

  1，在标签上直接加，就是隐藏

  2，hidden='{{true}}'

- 绑定事件--bind关键字

  1，bindinput：绑定表单输入事件

  1、1，获取事件源对象:event.detail.value

  1、1，双向绑定：将输入框的值传给num

  ​    this.setData({

  ​    num:e.detail.value

     //获取data中的数据：num:this.data.num

  ​     })

  2，bindtap:绑定点击事件

  2、1，无法在小程序事件中直接传入参数，会将参数当是事件名字的一部分；例如：fun(1)会当做整个方法名

  2、2，自定义属性传递参数：data-operation='{{1}}'

  2、3，获取自定属性,自定属性在event事件的currentTarget属性的dataset里面：

  const  operation = event.currentTarget.dataset.operation

6，小程序样式

不需要引入样式文件

rpx单位：当屏幕(page)是750，则像素是1：1

当屏幕是375，则是1：2

公式：1px = 750/page rpx

calc属性：计算比例widtn:calc(750rpx * 100 / 375)

其中750和px没有空格

引入wxss文件：只能使用相对路径

@import ‘文件路径’

7，小程序使用less文件

配置easy less插件，在设置json文件中加入

"less.compile": {     "outExt":    ".wxss"  }

// less使用法则：

// 1，@声明less变量

// 2，使用less变量

// 3，嵌套

// 4，使用@import直接导入其他less文件

## 小程序组件

**text标签的属性：**

1，长按文字复制：selectable，只有该标签有这个属性

2,解码：decode: &nbsp ;

<text selectable decode></text>//可以解码和长按复制

image图片标签：

1，src：指定路径

2，mode：模式，决定图片内容

​    1，scaleToFiall：按照设定拉伸

​    2，aspectFit:保持宽高比，常用

​    3，aspectFill：保持宽高比，只保证短边等完全显示出来

​    4，widthFix：宽度指定，高度会自定义，常用

图片懒加载：lazy-load,当图片出现在视口上下三屏之内，直接加载图片

**swiper：轮播图**

1，外层容器：swiper

2，内层容器：swiper-item

3，默认样式：宽度：100%，高度150px

image：默认320*240

无法按照原图比例缩放

原图：1150*370px

swiper 宽度 /swiper 高度 = 原图的宽度/原图的高度

swipeer 高度 = swiper*原图的高度 /原图的宽度

height ：100%、750rpx、100vw

=100vw*370、1150

**navigator：类似于a标签**

1，是一个块级标签

2，url：要跳转的链接

3，target：在哪个目标上发生跳转，默认self

4，open-type:跳转的方式

​    - 1，navigate:保留当前页面，也就是可以返回到当前页面不能跳转到tabbar

    - 2，redirect：关闭当前页面，不能跳转tabbar,以跳转当前页面消失
    - 3，switchTab：跳转到tabbar页面中，关闭其他非tabbar页面
    - 4，reLaunch：关闭所有页面，打开到应用的某个页面

button：按钮标签

1，size：按钮的大小

mini表示小尺寸

2，type：按钮的类型，即填充色

primary：绿色

default：白色

warn：红色

3，form-type：按钮的功能

submit：提交表单

reset：重置表单

4，open-type：提交方式

| 值             | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| contact        | 打开客服会话，如果⽤⼾在会话中点击消息卡⽚后返回⼩程序，可以从 bindcontact 回调中获得具体信息， |
| share          | 触发⽤⼾转发，使⽤前建议先阅读                               |
| getPhoneNumber | 获取⽤⼾信息，可以从bindgetuserinfo回调中获取到⽤⼾信息      |
| launchApp      | 打开APP，可以通过app-parameter属性设定向APP传的参数          |
| openSetting    | 打开授权设置⻚                                               |
| feedback       | 打开“意⻅反馈”⻚⾯，⽤⼾可提交反馈内容并上传⽇志，开发者可以登 录⼩程序管理后台后进⼊左侧菜单“客服反馈”⻚⾯获取到反馈内容 |
| getUserInfo    | 获取⽤⼾信息，可以从bindgetuserinfo回调中获取到⽤⼾信息      |

5，plain --镂空

 按钮是否镂空，背景⾊透明，直接加入

6、具体使用

```html
<button type="primary" plain bindgetuserinfo="handleGetUserInfo" open-type="getUserInfo"> 登录 </button>
```

导入incofont

1，去阿里巴巴图标库

https://www.iconfont.cn/

2，搜索图标，将需要的统一添加至某个项目中

3，在下载模式中点击font class

4，复制自动生成的代码地址在浏览器打开

5，将显示的代码样式全选

6，在小程序中的style项目下创建style.wxss文件并粘贴

7，在app.json中引入style

@import "./styles/style.wxss"

8，在任意项目中直接使用样式类

包括 iconfont 和 图标类

